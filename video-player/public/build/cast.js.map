{"version":3,"file":"build/cast.js","mappings":"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","sources":["webpack:///../shared/Peer.js","webpack:///./src/cast.js"],"sourcesContent":["function waitToCompleteIceGathering (pc, state = pc.iceGatheringState) {\r\n  return state !== 'complete' && new Promise(resolve => {\r\n    pc.addEventListener('icegatheringstatechange', () => (pc.iceGatheringState === 'complete') && resolve())\r\n  })\r\n}\r\n/**\r\n * @typedef {AddEventListenerOptions} Test~options\r\n * @property {AbortSignal} signal - funkis?\r\n */\r\n\r\nexport default class Peer {\r\n  /**\r\n   * @param {{\r\n   *   polite: boolean,\r\n   *   trickle: boolean,\r\n   *   iceServers: RTCIceServer[]\r\n   *   signal: AbortSignal\r\n   * }} [options]\r\n   */\r\n  constructor (options = {}) {\r\n    let { polite = true, trickle = true, quality = {} } = options\r\n\r\n    let { port1, port2 } = new MessageChannel()\r\n    let send = msg => port2.postMessage(JSON.stringify(msg))\r\n\r\n    const pc = new RTCPeerConnection({\r\n      iceServers: options?.iceServers || [{\r\n        urls: [\r\n          'stun:stun.l.google.com:19302',\r\n          'stun:global.stun.twilio.com:3478'\r\n        ]\r\n      }]\r\n    })\r\n\r\n    const ctrl = new AbortController()\r\n\r\n    /** @type {any} dummy alias for AbortSignal to make TS happy */\r\n    const signal = { signal: ctrl.signal }\r\n\r\n    pc.addEventListener('iceconnectionstatechange', () => {\r\n      if (\r\n        pc.iceConnectionState === 'disconnected' ||\r\n        pc.iceConnectionState === 'failed'\r\n      ) {\r\n        ctrl.abort()\r\n      }\r\n    }, signal)\r\n\r\n    const dc = pc.createDataChannel('both', { negotiated: true, id: 0 })\r\n\r\n    this.pc = pc\r\n    this.dc = dc\r\n    this.signal = ctrl.signal\r\n    this.polite = polite\r\n    this.signalingPort = port1\r\n\r\n    this.ready = new Promise(resolve => {\r\n      dc.addEventListener('open', () => {\r\n        // At this point we start to trickle over datachannel instead\r\n        // we also close the message channel as we do not need it anymore\r\n        trickle = true\r\n        send = (msg) => dc.send(JSON.stringify(msg))\r\n        port1.close()\r\n        port2.close()\r\n        this.ready = port2 = port1 = port2.onmessage = null\r\n        resolve()\r\n      }, { once: true, ...signal })\r\n    })\r\n\r\n    pc.addEventListener('icecandidate', ({ candidate }) => {\r\n      trickle && send({ candidate })\r\n    }, { ...signal })\r\n\r\n    // The rest is the polite peer negotiation logic, copied from this blog\r\n\r\n    let makingOffer = false; let ignoreOffer = false\r\n\r\n    pc.addEventListener('negotiationneeded', async () => {\r\n      makingOffer = true\r\n      const offer = await pc.createOffer()\r\n      if (pc.signalingState !== 'stable') return\r\n      offer.sdp = setQuality(offer.sdp, quality)\r\n      await pc.setLocalDescription(offer)\r\n      makingOffer = false\r\n      if (trickle) {\r\n        send({ description: pc.localDescription })\r\n      } else {\r\n        await waitToCompleteIceGathering(pc)\r\n        const description = pc.localDescription.toJSON()\r\n        description.sdp = description.sdp.replace(/a=ice-options:trickle\\s\\n/g, '')\r\n        send({ description })\r\n      }\r\n    }, { ...signal })\r\n\r\n    async function onmessage ({ data }) {\r\n      const { description, candidate } = typeof data === 'string' ? JSON.parse(data) : data\r\n\r\n      if (description) {\r\n        const offerCollision = description.type === 'offer' &&\r\n          (makingOffer || pc.signalingState !== 'stable')\r\n\r\n        ignoreOffer = !this.polite && offerCollision\r\n        if (ignoreOffer) {\r\n          return\r\n        }\r\n\r\n        if (offerCollision) {\r\n          await Promise.all([\r\n            pc.setLocalDescription({ type: 'rollback' }),\r\n            pc.setRemoteDescription(description)\r\n          ])\r\n        } else {\r\n          try {\r\n            (description.type === 'answer' && pc.signalingState === 'stable') ||\r\n              await pc.setRemoteDescription(description)\r\n          } catch (err) { }\r\n        }\r\n        if (description.type === 'offer') {\r\n          const answ = await pc.createAnswer()\r\n          answ.sdp = setQuality(answ.sdp, quality)\r\n          await pc.setLocalDescription(answ)\r\n          // Edge didn't set the state to 'new' after calling the above :[\r\n          if (!trickle) await waitToCompleteIceGathering(pc, 'new')\r\n          send({ description: pc.localDescription })\r\n        }\r\n      } else if (candidate) {\r\n        await pc.addIceCandidate(candidate)\r\n      }\r\n    }\r\n\r\n    port2.onmessage = onmessage.bind(this)\r\n    dc.addEventListener('message', onmessage.bind(this), { ...signal })\r\n  }\r\n}\r\n\r\n// I cannot describe the sheer anger and hatred I bear towards whoever came up with SDP\r\nfunction setQuality (sdp, opts = {}) {\r\n  if (!sdp || (!opts.video && !opts.audio)) return sdp\r\n  let newSDP = sdp\r\n  if (opts.video) { // bitrate, codecs[]\r\n    const videoData = sdp.matchAll(/^m=video.*SAVPF (.*)$/gm).next().value\r\n    if (videoData && videoData[1]) {\r\n      const RTPIndex = videoData[1]\r\n      const RTPMaps = {}\r\n      let last = null\r\n      for (const [match, id, type] of [...sdp.matchAll(/^a=rtpmap:(\\d{1,3}) (.*)\\/90000$/gm)]) {\r\n        if (type === 'rtx') {\r\n          RTPMaps[last].push(id)\r\n        } else {\r\n          if (!RTPMaps[type]) RTPMaps[type] = []\r\n          RTPMaps[type].push(id)\r\n          last = type\r\n          if (opts.video.bitrate) {\r\n            const fmtp = `a=fmtp:${id} x-google-min-bitrate=${opts.video.bitrate}; x-google-max-bitrate=${opts.video.bitrate}\\n`\r\n            newSDP = newSDP.replace(match, fmtp + match)\r\n          }\r\n        }\r\n      }\r\n      const newIndex = Object.entries(RTPMaps).sort((a, b) => {\r\n        const indexA = opts.video.codecs.indexOf(a[0])\r\n        const indexB = opts.video.codecs.indexOf(b[0])\r\n        return (indexA === -1 ? opts.video.codecs.length : indexA) - (indexB === -1 ? opts.video.codecs.length : indexB)\r\n      }).map(value => {\r\n        return value[1].join(' ')\r\n      }).join(' ')\r\n      newSDP = newSDP.replace(RTPIndex, newIndex)\r\n    }\r\n  }\r\n  if (opts.audio) {\r\n    const audioData = sdp.matchAll(/^a=rtpmap:(\\d{1,3}) opus\\/48000\\/2$/gm).next().value\r\n    if (audioData && audioData[0]) {\r\n      const regex = new RegExp(`^a=fmtp:${audioData[1]}.*$`, 'gm')\r\n      const FMTPData = sdp.match(regex)\r\n      if (FMTPData && FMTPData[0]) {\r\n        let newFMTPData = FMTPData[0].slice(0, FMTPData[0].indexOf(' ') + 1)\r\n        newFMTPData += 'stereo=' + (opts.audio.stereo != null ? opts.audio.stereo : '1')\r\n        newFMTPData += ';sprop-stereo=' + (opts.audio['sprop-stereo'] != null ? opts.audio['sprop-stereo'] : '1')\r\n\r\n        if (opts.audio.maxaveragebitrate != null) newFMTPData += '; maxaveragebitrate=' + (opts.audio.maxaveragebitrate || 128 * 1024 * 8)\r\n\r\n        if (opts.audio.maxplaybackrate != null) newFMTPData += '; maxplaybackrate=' + (opts.audio.maxplaybackrate || 128 * 1024 * 8)\r\n\r\n        if (opts.audio.cbr != null) newFMTPData += '; cbr=' + opts.audio.cbr\r\n\r\n        if (opts.audio.useinbandfec != null) newFMTPData += '; useinbandfec=' + opts.audio.useinbandfec\r\n\r\n        if (opts.audio.usedtx != null) newFMTPData += '; usedtx=' + opts.audio.usedtx\r\n\r\n        if (opts.audio.maxptime != null) newFMTPData += ';maxptime:' + opts.audio.maxptime\r\n        if (opts.audio.minptime != null) newFMTPData += '; minptime:' + opts.audio.minptime\r\n        newSDP = newSDP.replace(FMTPData[0], newFMTPData)\r\n      }\r\n    }\r\n  }\r\n  return newSDP\r\n}\r\n","import Peer from '../../shared/Peer.js'\r\n\r\nlet peer = null\r\nconst video = document.querySelector('video')\r\n\r\nfunction addConnection (connection) {\r\n  peer = new Peer({\r\n    polite: false,\r\n    quality: {\r\n      audio: {\r\n        stereo: 1,\r\n        'sprop-stereo': 1,\r\n        maxaveragebitrate: 510000,\r\n        maxplaybackrate: 510000,\r\n        cbr: 0,\r\n        useinbandfec: 1,\r\n        usedtx: 1,\r\n        maxptime: 20,\r\n        minptime: 10\r\n      },\r\n      video: {\r\n        bitrate: 2000000,\r\n        codecs: ['VP9', 'VP8', 'H264']\r\n      }\r\n    }\r\n  })\r\n\r\n  peer.pc.ontrack = evt => {\r\n    evt.receiver.playoutDelayHint = 0.5\r\n    if (!video.srcObject) {\r\n      video.srcObject = evt.streams[0]\r\n      video.volume = 1\r\n      video.play()\r\n    }\r\n  }\r\n\r\n  // only used to signal description and candidates to the other peer\r\n  // once a connection is establish the DataChannel takes over.\r\n  peer.signalingPort.onmessage = ({ data }) => {\r\n    connection.send(data)\r\n  }\r\n\r\n  connection.addEventListener('message', ({ data }) => {\r\n    peer.signalingPort.postMessage(data)\r\n  })\r\n}\r\n\r\nif (navigator.presentation.receiver) {\r\n  navigator.presentation.receiver.connectionList.then(list => {\r\n    list.connections.map(connection => addConnection(connection))\r\n    list.addEventListener('connectionavailable', event => {\r\n      addConnection(event.connection)\r\n    })\r\n  })\r\n}\r\n"],"names":["waitToCompleteIceGathering","pc","state","iceGatheringState","Promise","resolve","addEventListener","Peer","constructor","options","polite","trickle","quality","port1","port2","MessageChannel","send","msg","postMessage","JSON","stringify","RTCPeerConnection","iceServers","urls","ctrl","AbortController","signal","iceConnectionState","abort","dc","createDataChannel","negotiated","id","this","signalingPort","ready","close","onmessage","once","candidate","makingOffer","ignoreOffer","async","data","description","parse","offerCollision","type","signalingState","all","setLocalDescription","setRemoteDescription","err","answ","createAnswer","sdp","setQuality","localDescription","addIceCandidate","offer","createOffer","toJSON","replace","bind","opts","video","audio","newSDP","videoData","matchAll","next","value","RTPIndex","RTPMaps","last","match","push","bitrate","fmtp","newIndex","Object","entries","sort","a","b","indexA","codecs","indexOf","indexB","length","map","join","audioData","regex","RegExp","FMTPData","newFMTPData","slice","stereo","maxaveragebitrate","maxplaybackrate","cbr","useinbandfec","usedtx","maxptime","minptime","peer","document","querySelector","addConnection","connection","ontrack","evt","receiver","playoutDelayHint","srcObject","streams","volume","play","navigator","presentation","connectionList","then","list","connections","event"],"sourceRoot":""}