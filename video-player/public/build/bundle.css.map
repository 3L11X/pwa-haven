{"version":3,"file":"build/bundle.css","mappings":"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","sources":["webpack://video-player/./src/modules/Player.svelte","webpack://video-player/./src/modules/InstallPrompt.svelte","webpack://video-player/./src/App.svelte"],"sourcesContent":["<script>\r\n  import { onMount } from 'svelte'\r\n  import { setFile, speed } from './server.js'\r\n  import Peer from '../lib/peer.js'\r\n  import './File.js'\r\n  import Subtitles from './subtitles.js'\r\n  import { toTS, videoRx, requestTimeout, cancelTimeout } from './util.js'\r\n  import anitomyscript from 'anitomyscript'\r\n  import { URLFile } from './File.js'\r\n\r\n  $: updateFiles(files)\r\n  export let files = []\r\n  export let name = null\r\n  let src = null\r\n  let video = null\r\n  let container = null\r\n  let current = null\r\n  let subs = null\r\n  let duration = 0.1\r\n  let paused = true\r\n  let muted = false\r\n  let wasPaused = true\r\n  let thumbnail = ' '\r\n  let videos = []\r\n  let immersed = false\r\n  let buffering = false\r\n  let immerseTimeout = null\r\n  let bufferTimeout = null\r\n  let subHeaders = null\r\n  let pip = false\r\n  let presentationRequest = null\r\n  let presentationConnection = null\r\n  let canCast = false\r\n  let isFullscreen = false\r\n  let ended = false\r\n  let volume = localStorage.getItem('volume') || 1\r\n  let playbackRate = 1\r\n  $: localStorage.setItem('volume', volume)\r\n  onMount(() => {\r\n    if ('requestVideoFrameCallback' in HTMLVideoElement.prototype) {\r\n      video.addEventListener('loadeddata', () => {\r\n        video.fps = new Promise(resolve => {\r\n          let lastmeta = null\r\n          let count = 0\r\n\r\n          function handleFrames(now, metadata) {\r\n            if (count) {\r\n              // resolve on 2nd frame, 1st frame might be a cut-off\r\n              if (lastmeta) {\r\n                const msbf = (metadata.mediaTime - lastmeta.mediaTime) / (metadata.presentedFrames - lastmeta.presentedFrames)\r\n                const rawFPS = (1 / msbf).toFixed(3)\r\n                // this is accurate for mp4, mkv is a few ms off\r\n                if (current.name.endsWith('.mkv')) {\r\n                  if (rawFPS < 25 && rawFPS > 22) {\r\n                    resolve(23.976)\r\n                  } else if (rawFPS < 31 && rawFPS > 28) {\r\n                    resolve(29.97)\r\n                  } else if (rawFPS < 62 && rawFPS > 58) {\r\n                    resolve(59.94)\r\n                  } else {\r\n                    resolve(rawFPS) // smth went VERY wrong\r\n                  }\r\n                } else {\r\n                  resolve(rawFPS)\r\n                }\r\n              } else {\r\n                lastmeta = metadata\r\n                video.requestVideoFrameCallback(handleFrames)\r\n              }\r\n            } else {\r\n              count++\r\n              paused = false\r\n              video.requestVideoFrameCallback(handleFrames)\r\n            }\r\n          }\r\n          video.requestVideoFrameCallback(handleFrames)\r\n        })\r\n      })\r\n    } else {\r\n      video.fps = 23.976\r\n    }\r\n  })\r\n\r\n  if ('PresentationRequest' in window) {\r\n    const handleAvailability = aval => {\r\n      canCast = !!aval\r\n    }\r\n    presentationRequest = new PresentationRequest(['build/cast.html'])\r\n    presentationRequest.addEventListener('connectionavailable', e => initCast(e))\r\n    navigator.presentation.defaultRequest = presentationRequest\r\n    presentationRequest.getAvailability().then(aval => {\r\n      aval.onchange = e => handleAvailability(e.target.value)\r\n      handleAvailability(aval.value)\r\n    })\r\n  }\r\n\r\n  //document.fullscreenElement isn't reactive\r\n  document.addEventListener('fullscreenchange', () => {\r\n    isFullscreen = !!document.fullscreenElement\r\n  })\r\n\r\n  function handleHeaders() {\r\n    subHeaders = subs?.headers\r\n  }\r\n\r\n  function updateFiles(files) {\r\n    if (files && files.length) {\r\n      videos = files.filter(file => videoRx.test(file.name))\r\n      if (videos?.length) {\r\n        if (!current) {\r\n          handleCurrent(videos[0])\r\n        } else {\r\n          subs.files = files || []\r\n          subs.findSubtitleFiles(current)\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  async function handleCurrent(file) {\r\n    if (file) {\r\n      if (thumbnailData.video?.src) URL.revokeObjectURL(video?.src)\r\n      Object.assign(thumbnailData, {\r\n        thumbnails: [],\r\n        interval: undefined,\r\n        video: undefined\r\n      })\r\n      if (file instanceof File) {\r\n        setFile(file)\r\n        src = `server/${file.name}`\r\n        current = file\r\n        fast = false\r\n      } else {\r\n        await new Promise((resolve, reject) => {\r\n          if (!file.name.endsWith('.mkv')) return reject()\r\n          // check if the media can be fetched [CORS, origin, token etc]\r\n          fetch(file.url, { method: 'HEAD' })\r\n            .then(res => {\r\n              if (!res.ok) {\r\n                reject()\r\n              } else {\r\n                resolve()\r\n              }\r\n            })\r\n            .catch(reject)\r\n        })\r\n          .then(async () => {\r\n            const urlfile = new URLFile(file)\r\n            await urlfile.ready\r\n            setFile(urlfile)\r\n            src = `server/${urlfile.name}`\r\n            current = urlfile\r\n          })\r\n          .catch(() => {\r\n            setFile(null)\r\n            src = file.url\r\n            current = file\r\n          })\r\n      }\r\n    }\r\n  }\r\n  $: initSubs(current)\r\n\r\n  function initSubs(current) {\r\n    if (current) {\r\n      if (subs) subs.destroy()\r\n      subs = new Subtitles(video, files, current, handleHeaders)\r\n    }\r\n  }\r\n\r\n  let subDelay = 0\r\n  $: updateDelay(subDelay)\r\n  function updateDelay(delay) {\r\n    if (subs?.renderer) subs.renderer.timeOffset = delay\r\n  }\r\n\r\n  let currentTime = 0\r\n  $: progress = currentTime / duration\r\n  $: targetTime = (!paused && currentTime) || targetTime\r\n  function handleMouseDown({ target }) {\r\n    wasPaused = paused\r\n    paused = true\r\n    targetTime = target.value * duration\r\n  }\r\n  function handleMouseUp() {\r\n    paused = wasPaused\r\n    currentTime = targetTime\r\n  }\r\n  function handleProgress({ target }) {\r\n    targetTime = target.value * duration\r\n  }\r\n\r\n  function playPause() {\r\n    paused = !paused\r\n  }\r\n  function toggleMute() {\r\n    muted = !muted\r\n  }\r\n  function playNext() {\r\n    handleCurrent(videos[(videos.indexOf(current) + 1) % videos.length])\r\n  }\r\n  function playLast() {\r\n    const index = videos.indexOf(current)\r\n    handleCurrent(videos[index === 0 ? videos.length - 1 : index - 1])\r\n  }\r\n  function toggleFullscreen() {\r\n    document.fullscreenElement ? document.exitFullscreen() : container.requestFullscreen()\r\n  }\r\n  function seek(time) {\r\n    if (time === 85 && currentTime < 10) {\r\n      targetTime = currentTime = 90\r\n    } else if (time === 85 && duration - currentTime < 90) {\r\n      targetTime = currentTime = duration\r\n    } else {\r\n      targetTime = currentTime += time\r\n    }\r\n  }\r\n  function forward() {\r\n    seek(2)\r\n  }\r\n  function rewind() {\r\n    seek(-2)\r\n  }\r\n  function selectAudio(id) {\r\n    if (id !== undefined) {\r\n      for (const track of video.audioTracks) {\r\n        track.enabled = track.id === id\r\n      }\r\n      seek(-0.5) // stupid fix because video freezes up when chaging tracks\r\n    }\r\n  }\r\n  function toggleCast() {\r\n    if (video.readyState) {\r\n      if (presentationConnection) {\r\n        presentationConnection?.terminate()\r\n      } else {\r\n        presentationRequest.start()\r\n      }\r\n    }\r\n  }\r\n  async function togglePopout() {\r\n    if (video.readyState) {\r\n      await video.fps\r\n      if (!subs?.renderer) {\r\n        video !== document.pictureInPictureElement ? video.requestPictureInPicture() : document.exitPictureInPicture()\r\n        pip = !document.pictureInPictureElement\r\n      } else {\r\n        if (document.pictureInPictureElement && !document.pictureInPictureElement.id) {\r\n          // only exit if pip is the custom one, else overwrite existing pip with custom\r\n          document.exitPictureInPicture()\r\n          pip = !!document.pictureInPictureElement\r\n        } else {\r\n          const canvasVideo = document.createElement('video')\r\n          const { stream, destroy } = await getBurnIn()\r\n          canvasVideo.srcObject = stream\r\n          canvasVideo.onloadedmetadata = () => {\r\n            canvasVideo.play()\r\n            canvasVideo\r\n              .requestPictureInPicture()\r\n              .then(() => {\r\n                pip = !!document.pictureInPictureElement\r\n              })\r\n              .catch(e => {\r\n                pip = !!document.pictureInPictureElement\r\n                console.warn('Failed To Burn In Subtitles ' + e)\r\n                destroy()\r\n                canvasVideo.remove()\r\n              })\r\n          }\r\n          canvasVideo.onleavepictureinpicture = () => {\r\n            destroy()\r\n            canvasVideo.remove()\r\n            pip = !!document.pictureInPictureElement\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  function handleKeydown({ key }) {\r\n    switch (key) {\r\n      case ' ':\r\n        playPause()\r\n        break\r\n      case 'n':\r\n        playNext()\r\n        break\r\n      case 'm':\r\n        muted = !muted\r\n        break\r\n      case 'p':\r\n        togglePopout()\r\n        break\r\n      case 'f':\r\n        toggleFullscreen()\r\n        break\r\n      case 's':\r\n        seek(85)\r\n        break\r\n      case 'c':\r\n        toggleCast()\r\n        break\r\n      case 'ArrowLeft':\r\n        rewind()\r\n        break\r\n      case 'ArrowRight':\r\n        forward()\r\n        break\r\n      case 'ArrowUp':\r\n        volume = Math.min(1, volume + 0.05)\r\n        break\r\n      case 'ArrowDown':\r\n        volume = Math.max(0, volume - 0.05)\r\n        break\r\n      case '[':\r\n        playbackRate -= 0.1\r\n        break\r\n      case ']':\r\n        playbackRate += 0.1\r\n        break\r\n      case '\\\\':\r\n        playbackRate = 1\r\n        break\r\n    }\r\n  }\r\n\r\n  async function getBurnIn(noSubs) {\r\n    const canvas = document.createElement('canvas')\r\n    const context = canvas.getContext('2d', { alpha: false, colorSpace: 'display-p3' })\r\n    let loop = null\r\n    let destroy = null\r\n    canvas.width = video.videoWidth\r\n    canvas.height = video.videoHeight\r\n\r\n    if ('requestVideoFrameCallback' in HTMLVideoElement.prototype) {\r\n      const renderFrame = async () => {\r\n        context.drawImage(video, 0, 0)\r\n        if (!noSubs) context.drawImage(subs.renderer?.canvas, 0, 0, canvas.width, canvas.height)\r\n        loop = video.requestVideoFrameCallback(renderFrame)\r\n      }\r\n      loop = video.requestVideoFrameCallback(renderFrame)\r\n      destroy = () => {\r\n        video.cancelVideoFrameCallback(loop)\r\n        canvas.remove()\r\n      }\r\n    } else {\r\n      // for the firefox idiots\r\n      const fps = await video.fps\r\n      const renderFrame = async () => {\r\n        context.drawImage(video, 0, 0)\r\n        if (!noSubs) context.drawImage(subs.renderer?.canvas, 0, 0, canvas.width, canvas.height)\r\n        loop = requestTimeout(renderFrame, 500 / fps) // request x2 fps for smoothness\r\n      }\r\n      loop = requestAnimationFrame(renderFrame)\r\n      destroy = () => {\r\n        cancelTimeout(loop)\r\n        canvas.remove()\r\n      }\r\n    }\r\n    return { stream: canvas.captureStream(await video.fps), destroy }\r\n  }\r\n\r\n  function initCast(event) {\r\n    // these quality settings are likely to make cast overheat, oh noes!\r\n    let peer = new Peer({\r\n      polite: true,\r\n      quality: {\r\n        audio: {\r\n          stereo: 1,\r\n          'sprop-stereo': 1,\r\n          maxaveragebitrate: 510000,\r\n          maxplaybackrate: 510000,\r\n          cbr: 0,\r\n          useinbandfec: 1,\r\n          usedtx: 1,\r\n          maxptime: 20,\r\n          minptime: 10\r\n        },\r\n        video: {\r\n          bitrate: 2000000,\r\n          codecs: ['VP9', 'VP8', 'H264']\r\n        }\r\n      }\r\n    })\r\n\r\n    presentationConnection = event.connection\r\n    presentationConnection.addEventListener('terminate', () => {\r\n      presentationConnection = null\r\n      peer = null\r\n    })\r\n\r\n    peer.signalingPort.onmessage = ({ data }) => {\r\n      presentationConnection.send(data)\r\n    }\r\n\r\n    presentationConnection.addEventListener('message', ({ data }) => {\r\n      peer.signalingPort.postMessage(data)\r\n    })\r\n\r\n    peer.dc.onopen = async () => {\r\n      if (peer && presentationConnection) {\r\n        const tracks = []\r\n        const videostream = video.captureStream(await video.fps)\r\n        if (true) {\r\n          // TODO: check if cast supports codecs\r\n          const { stream, destroy } = await getBurnIn(!subs?.renderer)\r\n          tracks.push(stream.getVideoTracks()[0], videostream.getAudioTracks()[0])\r\n          presentationConnection.addEventListener('terminate', destroy)\r\n        } else {\r\n          tracks.push(videostream.getVideoTracks()[0], videostream.getAudioTracks()[0])\r\n        }\r\n        for (const track of tracks) {\r\n          peer.pc.addTrack(track, videostream)\r\n        }\r\n        paused = false // video pauses for some reason\r\n      }\r\n    }\r\n  }\r\n\r\n  function immersePlayer() {\r\n    immersed = true\r\n    immerseTimeout = undefined\r\n  }\r\n\r\n  function resetImmerse() {\r\n    if (immerseTimeout) {\r\n      clearTimeout(immerseTimeout)\r\n    } else {\r\n      immersed = false\r\n    }\r\n    immerseTimeout = setTimeout(immersePlayer, 8 * 1000)\r\n  }\r\n\r\n  function hideBuffering() {\r\n    if (bufferTimeout) {\r\n      clearTimeout(bufferTimeout)\r\n      bufferTimeout = null\r\n      buffering = false\r\n    }\r\n  }\r\n\r\n  function showBuffering() {\r\n    bufferTimeout = setTimeout(() => {\r\n      buffering = true\r\n      resetImmerse()\r\n    }, 150)\r\n  }\r\n  $: navigator.mediaSession?.setPositionState({\r\n    duration: Math.max(0, duration || 0),\r\n    playbackRate: 1,\r\n    position: Math.max(0, currentTime || 0)\r\n  })\r\n  async function dataURItoBlob(dataURI) {\r\n    const res = await fetch(dataURI)\r\n    const ab = await res.arrayBuffer()\r\n    return new Blob([ab], { type: 'image/png' })\r\n  }\r\n  async function mediaChange(current, image) {\r\n    if (current) {\r\n      const { release_group, anime_title, episode_number } = await anitomyscript(current.name)\r\n      // honestly, this is made for anime, but works fantastic for everything else.\r\n      name = [anime_title, episode_number].filter(i => i).join(' - ')\r\n      if ('mediaSession' in navigator) {\r\n        const metadata = image\r\n          ? new MediaMetadata({\r\n              title: name || 'Video Player',\r\n              artwork: [\r\n                {\r\n                  src: image,\r\n                  sizes: '256x256',\r\n                  type: 'image/jpg'\r\n                }\r\n              ]\r\n            })\r\n          : new MediaMetadata({\r\n              title: name || 'Video Player'\r\n            })\r\n        if (release_group) metadata.artist = release_group\r\n        navigator.mediaSession.metadata = metadata\r\n      }\r\n    }\r\n  }\r\n  $: mediaChange(current)\r\n\r\n  if ('mediaSession' in navigator) {\r\n    navigator.mediaSession.setActionHandler('play', playPause)\r\n    navigator.mediaSession.setActionHandler('pause', playPause)\r\n    navigator.mediaSession.setActionHandler('nexttrack', playNext)\r\n    navigator.mediaSession.setActionHandler('previoustrack', playLast)\r\n    navigator.mediaSession.setActionHandler('seekforward', forward)\r\n    navigator.mediaSession.setActionHandler('seekbackward', rewind)\r\n  }\r\n  let stats = null\r\n  let requestCallback = null\r\n  function toggleStats() {\r\n    if ('requestVideoFrameCallback' in HTMLVideoElement.prototype) {\r\n      if (requestCallback) {\r\n        stats = null\r\n        video.cancelVideoFrameCallback(requestCallback)\r\n        requestCallback = null\r\n      } else {\r\n        requestCallback = video.requestVideoFrameCallback((a, b) => {\r\n          stats = {}\r\n          handleStats(a, b)\r\n        })\r\n      }\r\n    }\r\n  }\r\n  async function handleStats(now, metadata) {\r\n    if (stats) {\r\n      stats = {\r\n        fps: await video.fps,\r\n        presented: metadata.presentedFrames,\r\n        processing: metadata.processingDuration + ' ms',\r\n        viewport: video.clientWidth + 'x' + video.clientHeight,\r\n        resolution: videoWidth + 'x' + videoHeight,\r\n        buffer: getBufferHealth(metadata.mediaTime) + ' s'\r\n      }\r\n      setTimeout(() => video.requestVideoFrameCallback(handleStats), 200)\r\n    }\r\n  }\r\n  function getBufferHealth(time) {\r\n    for (let index = video.buffered.length; index--; ) {\r\n      if (time < video.buffered.end(index) && time > video.buffered.start(index)) {\r\n        return parseInt(video.buffered.end(index) - time)\r\n      }\r\n    }\r\n  }\r\n  let fast = false\r\n  async function checkSpeed() {\r\n    if (!fast && current instanceof File && duration) {\r\n      const byterate = current.size / duration\r\n      const currBps = speed()\r\n      if (currBps > 5 * byterate) {\r\n        console.log('Access speed exceeds x5 bitrate')\r\n        fast = true\r\n        await subs?.parseSubtitles()\r\n        finishThumbnails()\r\n      }\r\n    }\r\n  }\r\n  const thumbCanvas = document.createElement('canvas')\r\n  thumbCanvas.width = 200\r\n  const thumbnailData = {\r\n    thumbnails: [],\r\n    canvas: thumbCanvas,\r\n    context: thumbCanvas.getContext('2d'),\r\n    interval: null,\r\n    video: null\r\n  }\r\n  let hover = null\r\n  let hoverTime = 0\r\n  let hoverOffset = 0\r\n  function handleHover({ offsetX, target }) {\r\n    hoverOffset = offsetX / target.clientWidth\r\n    hoverTime = duration * hoverOffset\r\n    hover.style.setProperty('left', hoverOffset * 100 + '%')\r\n    thumbnail = thumbnailData.thumbnails[Math.floor(hoverTime / thumbnailData.interval)] || ' '\r\n  }\r\n  function createThumbnail(vid = video) {\r\n    if (vid?.readyState >= 2) {\r\n      const index = Math.floor(vid.currentTime / thumbnailData.interval)\r\n      if (!thumbnailData.thumbnails[index]) {\r\n        thumbnailData.context.fillRect(0, 0, 200, thumbnailData.canvas.height)\r\n        thumbnailData.context.drawImage(vid, 0, 0, 200, thumbnailData.canvas.height)\r\n        thumbnailData.thumbnails[index] = thumbnailData.canvas.toDataURL('image/jpeg')\r\n        if (index === 5) mediaChange(current, thumbnailData.thumbnails[index])\r\n      }\r\n    }\r\n  }\r\n  $: initThumbnails(200 / (videoWidth / videoHeight))\r\n  function initThumbnails(height) {\r\n    if (!isNaN(height)) {\r\n      thumbnailData.interval = duration / 300 < 5 ? 5 : duration / 300\r\n      thumbnailData.canvas.height = height\r\n    }\r\n  }\r\n\r\n  function finishThumbnails() {\r\n    const t0 = performance.now()\r\n    const video = document.createElement('video')\r\n    let index = 0\r\n    video.preload = 'none'\r\n    video.volume = 0\r\n    video.playbackRate = 0\r\n    video.addEventListener('loadeddata', () => loadTime())\r\n    video.addEventListener('canplay', () => {\r\n      createThumbnail(thumbnailData.video)\r\n      loadTime()\r\n    })\r\n    thumbnailData.video = video\r\n    const loadTime = () => {\r\n      while (thumbnailData.thumbnails[index] && index <= Math.floor(thumbnailData.video.duration / thumbnailData.interval)) {\r\n        // only create thumbnails that are missing\r\n        index++\r\n      }\r\n      if (thumbnailData.video?.currentTime !== thumbnailData.video?.duration && thumbnailData.video) {\r\n        thumbnailData.video.currentTime = index * thumbnailData.interval\r\n      } else {\r\n        thumbnailData.video?.removeAttribute('src')\r\n        thumbnailData.video?.load()\r\n        thumbnailData.video?.remove()\r\n        delete thumbnailData.video\r\n        console.log('Thumbnail creating finished', index, toTS((performance.now() - t0) / 1000))\r\n      }\r\n      index++\r\n    }\r\n    thumbnailData.video.src = current instanceof File ? URL.createObjectURL(current) : current.url\r\n    thumbnailData.video.load()\r\n    console.log('Thumbnail creating started')\r\n  }\r\n  let isStandalone = window.matchMedia('(display-mode: standalone)').matches\r\n  window.matchMedia('(display-mode: standalone)').addEventListener('change', ({ matches }) => {\r\n    isStandalone = matches\r\n  })\r\n  let innerWidth, outerHeight, innerHeight, videoWidth, videoHeight\r\n  let menubarOffset = 0\r\n  $: calcMenubarOffset(innerWidth, outerHeight, innerHeight, videoWidth, videoHeight, isStandalone)\r\n  function calcMenubarOffset(innerWidth, outerHeight, innerHeight, videoWidth, videoHeight, isStandalone) {\r\n    // this can potentially be bad logic? could have some edge case animation transitions with css. idk tired.\r\n    if (isStandalone && videoWidth && videoHeight) {\r\n      const menubar = outerHeight - innerHeight\r\n      const ratio = videoWidth / videoHeight\r\n      // needs x2 menubar size [window/player bottom and screen top]\r\n      if ((innerHeight - videoHeight) * ratio > innerWidth - videoWidth + menubar * 2) {\r\n        // so windows is very dumb, and calculates windowed mode as if it was window XP, with the old bars, but not when maximised\r\n        const isMaximised = screen.availWidth === window.innerWidth && screen.availHeight === window.innerHeight\r\n        menubarOffset = (menubar / 2 + (navigator.appVersion.includes('Windows') && !isMaximised ? 8 : 0)) * -1\r\n      } else {\r\n        menubarOffset = 0\r\n      }\r\n    }\r\n  }\r\n</script>\r\n\r\n<svelte:window on:keydown={handleKeydown} bind:innerWidth bind:outerHeight bind:innerHeight />\r\n\r\n<!-- svelte-ignore a11y-media-has-caption -->\r\n<div\r\n  class=\"player w-full h-full d-flex flex-column\"\r\n  class:pip\r\n  class:immersed\r\n  class:buffering\r\n  bind:this={container}\r\n  on:mousemove={resetImmerse}\r\n  on:touchmove={resetImmerse}\r\n  on:keypress={resetImmerse}\r\n  on:mouseleave={immersePlayer}\r\n  on:contextmenu|preventDefault={toggleStats}>\r\n  <video\r\n    class=\"position-absolute h-full w-full\"\r\n    style={`margin-top: ${menubarOffset}px`}\r\n    autoplay\r\n    preload=\"auto\"\r\n    {src}\r\n    bind:videoHeight\r\n    bind:videoWidth\r\n    bind:this={video}\r\n    bind:volume\r\n    bind:duration\r\n    bind:currentTime\r\n    bind:paused\r\n    bind:ended\r\n    bind:muted\r\n    bind:playbackRate\r\n    on:timeupdate={checkSpeed}\r\n    on:timeupdate={() => createThumbnail()}\r\n    on:waiting={showBuffering}\r\n    on:loadeddata={hideBuffering}\r\n    on:canplay={hideBuffering}\r\n    on:playing={hideBuffering}\r\n    on:loadedmetadata={hideBuffering}\r\n    on:leavepictureinpicture={() => (pip = false)} />\r\n  <!-- svelte-ignore a11y-missing-content -->\r\n  {#if stats}\r\n    <div class=\"position-absolute top-0 nerd p-10 m-15 text-monospace rounded\">\r\n      FPS: {stats.fps}<br />\r\n      Presented frames: {stats.presented}<br />\r\n      Frame time: {stats.processing}<br />\r\n      Viewport: {stats.viewport}<br />\r\n      Resolution: {stats.resolution}<br />\r\n      Buffer health: {stats.buffer || 0}\r\n    </div>\r\n  {/if}\r\n  <div class=\"top z-50\" />\r\n  <div class=\"middle d-flex align-items-center justify-content-center flex-grow-1 z-50\">\r\n    <div class=\"position-abolute w-full h-full\" on:click={playPause} on:dblclick={toggleFullscreen} />\r\n    {#if videos?.length > 1}\r\n      <span class=\"material-icons ctrl\" data-name=\"playLast\" on:click={playLast}> skip_previous </span>\r\n    {/if}\r\n    <span class=\"material-icons ctrl\" data-name=\"rewind\" on:click={rewind}> fast_rewind </span>\r\n    <span class=\"material-icons ctrl\" data-name=\"playPause\" on:click={playPause}> {ended ? 'replay' : paused ? 'play_arrow' : 'pause'} </span>\r\n    <span class=\"material-icons ctrl\" data-name=\"forward\" on:click={forward}> fast_forward </span>\r\n    {#if videos?.length > 1}\r\n      <span class=\"material-icons ctrl\" data-name=\"playNext\" on:click={playNext}> skip_next </span>\r\n    {/if}\r\n    <div data-name=\"bufferingDisplay\" class=\"position-absolute\" />\r\n  </div>\r\n  <div class=\"bottom d-flex z-50\">\r\n    <span class=\"material-icons ctrl\" title=\"Play/Pause [Space]\" data-name=\"playPause\" on:click={playPause}> {ended ? 'replay' : paused ? 'play_arrow' : 'pause'} </span>\r\n    {#if videos?.length > 1}\r\n      <span class=\"material-icons ctrl\" title=\"Next [N]\" data-name=\"playNext\" on:click={playNext}> skip_next </span>\r\n    {/if}\r\n    <div class=\"d-flex w-auto volume\">\r\n      <span class=\"material-icons ctrl\" title=\"Mute [M]\" data-name=\"toggleMute\" on:click={toggleMute}> {muted ? 'volume_off' : 'volume_up'} </span>\r\n      <input class=\"ctrl\" type=\"range\" min=\"0\" max=\"1\" step=\"any\" data-name=\"setVolume\" bind:value={volume} style=\"--value: {volume * 100}%\" />\r\n    </div>\r\n    <!-- svelte-ignore missing-declaration -->\r\n    {#if 'audioTracks' in HTMLVideoElement.prototype && video?.audioTracks?.length > 1}\r\n      <div class=\"audio-tracks dropdown dropup with-arrow\">\r\n        <span class=\"material-icons ctrl\" title=\"Audio Tracks [T]\" id=\"baudio\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\" data-name=\"audioButton\">\r\n          queue_music\r\n        </span>\r\n        <div class=\"dropdown-menu dropdown-menu-left ctrl custom-radio p-10 pb-5 text-capitalize\" aria-labelledby=\"baudio\" data-name=\"selectAudio\">\r\n          {#each video.audioTracks as track}\r\n            <input name=\"audio-radio-set\" type=\"radio\" id=\"audio-{track.id}-radio\" value={track.id} checked={track.enabled} />\r\n            <label for=\"audio-{track.id}-radio\" on:click={() => selectAudio(track.id)} class=\"text-truncate pb-5\">\r\n              {(track.language || (!Object.values(video.audioTracks).some(track => track.language === 'eng' || track.language === 'en') ? 'eng' : track.label)) +\r\n                (track.label ? ' - ' + track.label : '')}</label>\r\n          {/each}\r\n        </div>\r\n      </div>\r\n    {/if}\r\n    <div class=\"w-full d-flex align-items-center\" data-name=\"progressWrapper\">\r\n      <div class=\"ts\">{toTS(targetTime)}</div>\r\n      <div class=\"w-full h-full position-relative\">\r\n        <input\r\n          class=\"ctrl w-full h-full\"\r\n          type=\"range\"\r\n          min=\"0\"\r\n          max=\"1\"\r\n          step=\"any\"\r\n          data-name=\"setProgress\"\r\n          bind:value={progress}\r\n          on:mousedown={handleMouseDown}\r\n          on:mouseup={handleMouseUp}\r\n          on:mousemove={handleHover}\r\n          on:input={handleProgress}\r\n          on:touchstart={handleMouseDown}\r\n          on:touchend={handleMouseUp}\r\n          style=\"--value: {progress * 100}%\" />\r\n        <div class=\"hover position-absolute d-flex flex-column align-items-center\" bind:this={hover}>\r\n          <img alt=\"thumbnail\" class=\"w-full mb-5 shadow-lg\" src={thumbnail} />\r\n          <div class=\"ts\">{toTS(hoverTime)}</div>\r\n        </div>\r\n      </div>\r\n      <div class=\"ts\">{toTS(duration)}</div>\r\n    </div>\r\n    {#if subHeaders?.length}\r\n      <div class=\"subtitles dropdown dropup with-arrow\">\r\n        <span class=\"material-icons ctrl\" title=\"Subtitles\" id=\"bcap\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\" data-name=\"captionsButton\">\r\n          subtitles\r\n        </span>\r\n        <div class=\"dropdown-menu dropdown-menu-right ctrl custom-radio p-10 pb-5 text-capitalize\" aria-labelledby=\"bcap\" data-name=\"selectCaptions\">\r\n          {#each subHeaders as track}\r\n            {#if track}\r\n              <input name=\"subtitle-radio-set\" type=\"radio\" id=\"subtitle-{track.number}-radio\" value={track.numer} checked={track.number === subs.current} />\r\n              <label for=\"subtitle-{track.nubmer}-radio\" on:click={() => subs.selectCaptions(track.number)} class=\"text-truncate pb-5\">\r\n                {(track.language || (!Object.values(subs.headers).some(header => header.language === 'eng' || header.language === 'en') ? 'eng' : track.type)) +\r\n                  (track.name ? ' - ' + track.name : '')}\r\n              </label>\r\n            {/if}\r\n          {/each}\r\n          <input type=\"number\" step=\"0.1\" bind:value={subDelay} class=\"form-control text-right form-control-sm\" />\r\n        </div>\r\n      </div>\r\n    {/if}\r\n    {#if 'PresentationRequest' in window && canCast}\r\n      <span class=\"material-icons ctrl\" title=\"Cast Video [C]\" data-name=\"toggleCast\" on:click={toggleCast}>\r\n        {presentationConnection ? 'cast_connected' : 'cast'}\r\n      </span>\r\n    {/if}\r\n    {#if 'pictureInPictureEnabled' in document}\r\n      <span class=\"material-icons ctrl\" title=\"Popout Window [P]\" data-name=\"togglePopout\" on:click={togglePopout}>\r\n        {pip ? 'featured_video' : 'picture_in_picture'}\r\n      </span>\r\n    {/if}\r\n    <span class=\"material-icons ctrl\" title=\"Fullscreen [F]\" data-name=\"toggleFullscreen\" on:click={toggleFullscreen}>\r\n      {isFullscreen ? 'fullscreen_exit' : 'fullscreen'}\r\n    </span>\r\n  </div>\r\n</div>\r\n\r\n<style>\r\n  .nerd {\r\n    background: #000000bb;\r\n  }\r\n  video {\r\n    transition: margin-top 0.2s ease;\r\n  }\r\n  .player {\r\n    user-select: none;\r\n    font-family: Roboto, Arial, Helvetica, sans-serif;\r\n    transition: width 0.2s ease;\r\n    background: #000;\r\n  }\r\n\r\n  .pip :global(canvas) {\r\n    left: 99.9% !important;\r\n    /*hack to hide the canvas but still keep it updating*/\r\n  }\r\n\r\n  .material-icons {\r\n    font-size: 2.2rem;\r\n    padding: 1.2rem;\r\n    transition: all 0.2s ease;\r\n    display: flex;\r\n  }\r\n\r\n  .immersed {\r\n    cursor: none;\r\n  }\r\n\r\n  .immersed .middle .ctrl,\r\n  .immersed .bottom {\r\n    opacity: 0;\r\n  }\r\n\r\n  .bottom img[src=' '],\r\n  :fullscreen .ctrl[data-name='toggleCast'],\r\n  :fullscreen .ctrl[data-name='togglePopout'] {\r\n    display: none !important;\r\n  }\r\n\r\n  .pip video {\r\n    visibility: hidden;\r\n  }\r\n\r\n  .middle div[data-name='bufferingDisplay'] {\r\n    border: 4px solid #ffffff00;\r\n    border-top: 4px solid #fff;\r\n    border-radius: 50%;\r\n    width: 40px;\r\n    height: 40px;\r\n    animation: spin 1s linear infinite;\r\n    opacity: 0;\r\n    transition: 0.5s opacity ease;\r\n    filter: drop-shadow(0 0 8px #000);\r\n  }\r\n\r\n  .buffering .middle div[data-name='bufferingDisplay'] {\r\n    opacity: 1 !important;\r\n  }\r\n\r\n  @keyframes spin {\r\n    0% {\r\n      transform: rotate(0deg);\r\n    }\r\n\r\n    100% {\r\n      transform: rotate(360deg);\r\n    }\r\n  }\r\n\r\n  .middle .ctrl {\r\n    font-size: 4rem;\r\n    margin: 2rem;\r\n    z-index: 3;\r\n    display: none;\r\n  }\r\n\r\n  @media (pointer: none), (pointer: coarse) {\r\n    .middle .ctrl {\r\n      display: flex;\r\n    }\r\n  }\r\n\r\n  .middle .ctrl[data-name='playPause'] {\r\n    font-size: 6rem;\r\n  }\r\n\r\n  .middle .ctrl,\r\n  .bottom .ctrl:hover,\r\n  .bottom .ts:hover,\r\n  .bottom .hover .ts {\r\n    filter: drop-shadow(0 0 8px #000);\r\n  }\r\n\r\n  .bottom {\r\n    background: linear-gradient(to top, rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0.4) 25%, rgba(0, 0, 0, 0.2) 50%, rgba(0, 0, 0, 0.1) 75%, transparent);\r\n    transition: 0.5s opacity ease;\r\n  }\r\n\r\n  .bottom .ctrl {\r\n    cursor: pointer;\r\n  }\r\n\r\n  input[type='range'] {\r\n    -webkit-appearance: none;\r\n    background: transparent;\r\n    margin: 0;\r\n    cursor: pointer;\r\n    height: 8px;\r\n  }\r\n\r\n  input[type='range']:focus {\r\n    outline: none;\r\n  }\r\n\r\n  input[type='range']::-webkit-slider-runnable-track {\r\n    height: 3px;\r\n  }\r\n\r\n  input[type='range']::-moz-range-track {\r\n    height: 3px;\r\n    border: none;\r\n  }\r\n\r\n  input[type='range']::-webkit-slider-thumb {\r\n    height: 0;\r\n    width: 0;\r\n    border-radius: 50%;\r\n    background: #ff3c00;\r\n    -webkit-appearance: none;\r\n    appearance: none;\r\n    transition: all 0.1s ease;\r\n  }\r\n  input[type='range']::-moz-range-thumb {\r\n    height: 0;\r\n    width: 0;\r\n    border-radius: 50%;\r\n    background: #ff3c00;\r\n    -webkit-appearance: none;\r\n    appearance: none;\r\n    transition: all 0.1s ease;\r\n    border: none;\r\n  }\r\n\r\n  input[type='range']:hover::-webkit-slider-thumb {\r\n    height: 12px;\r\n    width: 12px;\r\n    margin-top: -4px;\r\n  }\r\n\r\n  input[type='range']:hover::-moz-range-thumb {\r\n    height: 12px;\r\n    width: 12px;\r\n    margin-top: -4px;\r\n  }\r\n\r\n  input[type='range']::-moz-range-track {\r\n    background: linear-gradient(90deg, #ff3c00 var(--value), rgba(255, 255, 255, 0.2) var(--value));\r\n  }\r\n  input[type='range']::-webkit-slider-runnable-track {\r\n    background: linear-gradient(90deg, #ff3c00 var(--value), rgba(255, 255, 255, 0.2) var(--value));\r\n  }\r\n  .bottom .volume:hover input[type='range'] {\r\n    width: 5vw;\r\n    display: inline-block;\r\n    transition: all 0.1s ease;\r\n    margin-right: 1rem;\r\n  }\r\n\r\n  .bottom .volume input[type='range'] {\r\n    width: 0;\r\n    transition: all 0.1s ease;\r\n    height: 100%;\r\n  }\r\n\r\n  .bottom [data-name='setProgress'] ~ .hover {\r\n    opacity: 0;\r\n    top: 1.2rem;\r\n    transform: translate(-50%, -100%);\r\n    position: absolute;\r\n    font-family: Roboto, Arial, Helvetica, sans-serif;\r\n    white-space: nowrap;\r\n    font-weight: 600;\r\n    width: 200px;\r\n    transition: 0.2s opacity ease;\r\n  }\r\n\r\n  .bottom [data-name='setProgress']:hover ~ .hover {\r\n    opacity: 1;\r\n  }\r\n\r\n  .bottom div[data-name='progressWrapper'] .ts {\r\n    color: #ececec;\r\n    font-size: 1.8rem !important;\r\n    white-space: nowrap;\r\n    align-self: center;\r\n    line-height: var(--base-line-height);\r\n    padding: 0 1.2rem;\r\n    font-weight: 600;\r\n  }\r\n\r\n  @media (pointer: none), (pointer: coarse) {\r\n    .bottom .ctrl[data-name='playPause'],\r\n    .bottom .ctrl[data-name='playNext'],\r\n    .bottom .volume,\r\n    .bottom .ctrl[data-name='toggleFullscreen'] {\r\n      display: none;\r\n    }\r\n  }\r\n\r\n  ::-webkit-inner-spin-button {\r\n    opacity: 1;\r\n    margin-left: 0.4rem;\r\n    margin-right: -0.5rem;\r\n    filter: invert(0.84);\r\n    padding-top: 2rem;\r\n  }\r\n\r\n  /* Radio debloat for halfmoon */\r\n  .custom-radio {\r\n    display: flex;\r\n    flex-direction: column;\r\n  }\r\n  .custom-radio label {\r\n    position: relative;\r\n  }\r\n  .custom-radio input[type='radio']:hover + label:before {\r\n    background-color: var(--lm-radio-bg-color-hover);\r\n    border-color: var(--lm-radio-border-color-hover);\r\n  }\r\n  .custom-radio input[type='radio']:focus + label:before {\r\n    border-color: var(--lm-radio-border-color-focus);\r\n    -moz-box-shadow: var(--lm-radio-box-shadow-focus);\r\n    -webkit-box-shadow: var(--lm-radio-box-shadow-focus);\r\n    box-shadow: var(--lm-radio-box-shadow-focus);\r\n  }\r\n  .custom-radio input[type='radio']:checked + label:before {\r\n    background-color: var(--lm-radio-bg-color-checked);\r\n    border-color: var(--lm-radio-border-color-checked);\r\n  }\r\n  .custom-radio input[type='radio']:checked:focus + label:before {\r\n    border-color: var(--lm-radio-border-color-checked-focus);\r\n    -moz-box-shadow: var(--lm-radio-box-shadow-checked-focus);\r\n    -webkit-box-shadow: var(--lm-radio-box-shadow-checked-focus);\r\n    box-shadow: var(--lm-radio-box-shadow-checked-focus);\r\n  }\r\n  .dark-mode .custom-radio label:before {\r\n    background-color: var(--dm-radio-bg-color);\r\n    border-color: var(--dm-radio-border-color);\r\n  }\r\n  .dark-mode .custom-radio input[type='radio']:hover + label:before {\r\n    background-color: var(--dm-radio-bg-color-hover);\r\n    border-color: var(--dm-radio-border-color-hover);\r\n  }\r\n  .dark-mode .custom-radio input[type='radio']:focus + label:before {\r\n    border-color: var(--dm-radio-border-color-focus);\r\n    -moz-box-shadow: var(--dm-radio-box-shadow-focus);\r\n    -webkit-box-shadow: var(--dm-radio-box-shadow-focus);\r\n    box-shadow: var(--dm-radio-box-shadow-focus);\r\n  }\r\n  .dark-mode .custom-radio input[type='radio']:checked + label:before {\r\n    background-color: var(--dm-radio-bg-color-checked);\r\n    border-color: var(--dm-radio-border-color-checked);\r\n  }\r\n  .dark-mode .custom-radio input[type='radio']:checked:focus + label:before {\r\n    border-color: var(--dm-radio-border-color-checked-focus);\r\n    -moz-box-shadow: var(--dm-radio-box-shadow-checked-focus);\r\n    -webkit-box-shadow: var(--dm-radio-box-shadow-checked-focus);\r\n    box-shadow: var(--dm-radio-box-shadow-checked-focus);\r\n  }\r\n  .custom-radio label:after {\r\n    content: '';\r\n    position: absolute;\r\n    display: none;\r\n    top: var(--radio-checkmark-top);\r\n    left: var(--radio-checkmark-left);\r\n    width: var(--radio-checkmark-width-height);\r\n    height: var(--radio-checkmark-width-height);\r\n    background-color: var(--lm-radio-checkmark-color);\r\n    border-radius: var(--radio-checkmark-border-radius);\r\n  }\r\n  .custom-radio input[type='radio']:checked + label:after {\r\n    display: block;\r\n  }\r\n  .custom-radio input[type='radio']:disabled + label {\r\n    opacity: 0.6;\r\n    cursor: not-allowed;\r\n  }\r\n  .custom-radio input[type='radio']:disabled + label:before,\r\n  .custom-radio input[type='radio']:hover:disabled + label:before {\r\n    background-color: var(--lm-radio-bg-color);\r\n    border-color: var(--lm-radio-border-color);\r\n  }\r\n  .custom-radio input[type='radio']:disabled:checked + label:before,\r\n  .custom-radio input[type='radio']:hover:disabled:checked + label:before {\r\n    background-color: var(--lm-radio-bg-color-checked);\r\n    border-color: var(--lm-radio-border-color-checked);\r\n  }\r\n  .dark-mode .custom-radio input[type='radio']:disabled + label:before,\r\n  .dark-mode .custom-radio input[type='radio']:hover:disabled + label:before {\r\n    background-color: var(--dm-radio-bg-color);\r\n    border-color: var(--dm-radio-border-color);\r\n  }\r\n  .dark-mode .custom-radio input[type='radio']:disabled:checked + label:before,\r\n  .dark-mode .custom-radio input[type='radio']:hover:disabled:checked + label:before {\r\n    background-color: var(--dm-radio-bg-color-checked);\r\n    border-color: var(--dm-radio-border-color-checked);\r\n  }\r\n</style>\r\n","<script>\r\n  let deferredPrompt\r\n\r\n  window.addEventListener('beforeinstallprompt', e => {\r\n    e.preventDefault()\r\n    deferredPrompt = e\r\n  })\r\n  async function promptInstall() {\r\n    deferredPrompt.prompt()\r\n    const { outcome } = await deferredPrompt.userChoice\r\n    if (outcome === 'accepted') {\r\n      deferredPrompt = null\r\n    }\r\n  }\r\n  function dismiss() {\r\n    deferredPrompt = null\r\n  }\r\n</script>\r\n\r\n{#if deferredPrompt}\r\n  <div class=\"alert alert-success filled-dm show\" on:click={promptInstall}>\r\n    <h4 class=\"alert-heading\">Install</h4>\r\n    <button class=\"close\" type=\"button\" on:click={dismiss}><span>×</span></button>\r\n    Click here to install the app for more features!\r\n  </div>\r\n{/if}\r\n\r\n<style>\r\n  .alert {\r\n    display: block !important;\r\n    animation: fly-in 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);\r\n  }\r\n\r\n  @keyframes fly-in {\r\n    0% {\r\n      right: -50rem;\r\n    }\r\n    100% {\r\n      right: 0;\r\n    }\r\n  }\r\n</style>\r\n","<script>\r\n  import Player from './modules/Player.svelte'\r\n  import { videoRx, subRx } from './modules/util.js'\r\n  import InstallPrompt from './modules/InstallPrompt.svelte'\r\n\r\n  const DOMPARSER = new DOMParser().parseFromString.bind(new DOMParser())\r\n  let name = ''\r\n  let files = []\r\n\r\n  // mistakes have been made\r\n  if (navigator.serviceWorker?.controller?.scriptURL.endsWith('server-worker.js')) {\r\n    navigator.serviceWorker.ready.then(reg => {\r\n      reg.unregister().then(() => location.reload())\r\n    })\r\n  }\r\n\r\n  // loading files\r\n  function handleDrop({ dataTransfer }) {\r\n    handleItems([...dataTransfer.items])\r\n  }\r\n\r\n  function handlePaste({ clipboardData }) {\r\n    handleItems([...clipboardData.items])\r\n  }\r\n\r\n  async function handleItems(items) {\r\n    const promises = items.map(item => {\r\n      if (item.type.indexOf('video/') === 0) {\r\n        return item.getAsFile()\r\n      }\r\n      if (item.type === 'text/plain') {\r\n        if (item.kind === 'string') {\r\n          return new Promise(resolve => {\r\n            item.getAsString(url => {\r\n              if (videoRx.test(url) || subRx.test(url)) {\r\n                const name = url.substring(Math.max(url.lastIndexOf('\\\\') + 2, url.lastIndexOf('/') + 1))\r\n                resolve({\r\n                  name,\r\n                  url\r\n                })\r\n              }\r\n              resolve()\r\n            })\r\n          })\r\n        } else if (item.kind === 'file') {\r\n          return item.getAsFile()\r\n        }\r\n      }\r\n      if (item.type === 'text/html') {\r\n        return new Promise(resolve =>\r\n          item.getAsString(string => {\r\n            const elems = DOMPARSER(string, 'text/html').querySelectorAll('video')\r\n            if (elems.length)\r\n              resolve(\r\n                elems.map(video => {\r\n                  const name = video.src.substring(Math.max(video.src.lastIndexOf('\\\\') + 2, video.src.lastIndexOf('/') + 1))\r\n                  return { url: video.src, name }\r\n                })\r\n              )\r\n            resolve()\r\n          })\r\n        )\r\n      }\r\n      if (!item.type) {\r\n        let entry = item.webkitGetAsEntry()\r\n        if (entry?.isDirectory) {\r\n          return new Promise(resolve => {\r\n            folder.createReader().readEntries(async entries => {\r\n              const filePromises = entries.filter(entry => entry.isFile).map(file => new Promise(resolve => file.file(resolve)))\r\n              resolve(await Promise.all(filePromises))\r\n            })\r\n          })\r\n        } else if (entry && !entry.isDirectory) {\r\n          if (videoRx.test(entry.name) || subRx.test(entry.name)) {\r\n            return new Promise(resolve => entry.file(resolve))\r\n          }\r\n        }\r\n        return\r\n      }\r\n      return\r\n    })\r\n    files = files.concat((await Promise.all(promises)).flat().filter(i => i))\r\n    console.log(files)\r\n  }\r\n\r\n  if ('launchQueue' in window) {\r\n    launchQueue.setConsumer(async launchParams => {\r\n      if (!launchParams.files.length) {\r\n        return\r\n      }\r\n      const promises = launchParams.files.map(file => file.getFile())\r\n      // for some fucking reason, the same file can get passed multiple times, why? I still want to future-proof multi-files\r\n      files = (await Promise.all(promises)).filter((file, index, all) => {\r\n        return (\r\n          all.findIndex(search => {\r\n            return search.name === file.name && search.size === file.size && search.lastModified === file.lastModified\r\n          }) === index\r\n        )\r\n      })\r\n    })\r\n  }\r\n  const search = new URLSearchParams(location.search)\r\n  for (const param of search) {\r\n    if (videoRx.test(param[1]) || subRx.test(param[1])) {\r\n      const name = param[1].substring(Math.max(param[1].lastIndexOf('\\\\') + 2, param[1].lastIndexOf('/') + 1))\r\n      files.push({\r\n        name,\r\n        url: param[1]\r\n      })\r\n    }\r\n  }\r\n  function handlePopup() {\r\n    if (!files.length) {\r\n      let input = document.createElement('input')\r\n      input.type = 'file'\r\n      input.multiple = 'multiple'\r\n\r\n      input.onchange = ({ target }) => {\r\n        files = [...target.files]\r\n        input = null\r\n      }\r\n      input.click()\r\n    }\r\n  }\r\n</script>\r\n\r\n<div class=\"sticky-alerts d-flex flex-column-reverse\">\r\n  <InstallPrompt />\r\n</div>\r\n<div class=\"page-wrapper\" on:click={handlePopup}>\r\n  <Player bind:files bind:name />\r\n</div>\r\n\r\n<svelte:head>\r\n  <title>{name || 'Video Player'}</title>\r\n</svelte:head>\r\n\r\n<svelte:window on:drop|preventDefault={handleDrop} on:dragover|preventDefault on:paste|preventDefault={handlePaste} />\r\n\r\n<style>\r\n  * {\r\n    user-select: none;\r\n  }\r\n  .sticky-alerts {\r\n    --sticky-alerts-top: auto;\r\n    bottom: 1rem;\r\n  }\r\n</style>\r\n"],"names":[],"sourceRoot":""}