{"version":3,"file":"build/bundle.css","mappings":"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","sources":["webpack:///../node_modules/svelte-keybinds/Keybinds.svelte","webpack:///./src/modules/Player.svelte","webpack:///../shared/InstallPrompt.svelte","webpack:///../shared/RecentFiles.svelte","webpack:///./src/App.svelte"],"sourcesContent":["<script context=\"module\">\r\n  import { writable } from 'svelte/store';\r\n  import { keys, layout } from './maps.js';\r\n\r\n  let kbn = null;\r\n\r\n  export let binds = writable(null);\r\n  binds.subscribe((obj) => {\r\n    kbn = obj ?? {};\r\n  });\r\n\r\n  let cnd = null;\r\n\r\n  export const condition = writable(() => true);\r\n  condition.subscribe((fn) => {\r\n    if (typeof fn !== 'function') throw new Error('Condition must be a function');\r\n    cnd = fn;\r\n  });\r\n\r\n  window.addEventListener('keydown', runBind);\r\n\r\n  async function runBind(e) {\r\n    if (await cnd(e)) kbn[layout[e.code] || e.code]?.fn?.(e);\r\n  }\r\n\r\n  export function loadWithDefaults(defaults) {\r\n    const def = toIDmap(defaults);\r\n    const saved = JSON.parse(localStorage.getItem('thaunknown/svelte-keybinds'));\r\n    for (const id in saved) {\r\n      saved[id].fn = def[id].fn;\r\n    }\r\n    binds.set(toKeyMap({ ...def, ...saved }));\r\n  }\r\n\r\n  function toIDmap(target = {}) {\r\n    const obj = {};\r\n    for (const code in target) {\r\n      const bind = target[code];\r\n      obj[bind.id] = { ...bind, code };\r\n    }\r\n    return obj;\r\n  }\r\n\r\n  function toKeyMap(target = {}) {\r\n    const obj = {};\r\n    for (const code in target) {\r\n      const bind = target[code];\r\n      obj[bind.code] = { ...bind, code };\r\n    }\r\n    return obj;\r\n  }\r\n\r\n  function save() {\r\n    localStorage.setItem('thaunknown/svelte-keybinds', JSON.stringify(toIDmap(kbn)));\r\n  }\r\n</script>\r\n\r\n<script>\r\n  export let autosave = false;\r\n\r\n  export let clickable = false;\r\n\r\n  const kbnref = kbn;\r\n  let dragged = null;\r\n  function draggable(node, code) {\r\n    let drag = false;\r\n    node.addEventListener('dragstart', ({ target }) => {\r\n      dragged = target;\r\n      target.classList.add('transparent');\r\n      drag = true;\r\n    });\r\n    node.addEventListener('dragend', ({ target }) => {\r\n      target.classList.remove('transparent');\r\n      drag = false;\r\n    });\r\n    node.addEventListener('dragover', (e) => {\r\n      e.dataTransfer.dropEffect = 'move';\r\n      e.preventDefault();\r\n      if (!drag) e.target.classList.add('transparent');\r\n    });\r\n    node.addEventListener('dragleave', ({ target }) => {\r\n      if (!drag) target.classList.remove('transparent');\r\n    });\r\n    node.addEventListener('drop', ({ target }) => {\r\n      target.style.opacity = null;\r\n      const targetcode = dragged.dataset.code;\r\n      if (kbnref[code]) {\r\n        const temp = kbnref[targetcode];\r\n        kbnref[targetcode] = kbnref[code];\r\n        kbnref[code] = temp;\r\n      } else {\r\n        kbnref[code] = kbnref[targetcode];\r\n        delete kbnref[targetcode];\r\n      }\r\n      binds.set(kbnref);\r\n      if (autosave === true) {\r\n        save();\r\n      }\r\n    });\r\n  }\r\n</script>\r\n\r\n<div class=\"svelte-keybinds\">\r\n  {#each Object.values(keys) as key}\r\n    {@const { size, dark, name } = key}\r\n    <div\r\n      class:dark\r\n      draggable={kbnref[name] ? true : false}\r\n      data-code={name}\r\n      class=\"w-{size || 50}\"\r\n      {...$$restProps}\r\n      use:draggable={name}\r\n      on:click={(e) => clickable && runBind(Object.assign(e, { code: name }))}>\r\n      <slot prop={kbnref[name]} />\r\n    </div>\r\n  {/each}\r\n</div>\r\n\r\n<style>\r\n  .svelte-keybinds {\r\n    flex-shrink: 0;\r\n    user-select: none;\r\n    display: flex;\r\n    flex-wrap: wrap;\r\n    width: 82em;\r\n    background: rgba(0, 0, 0, 0.8);\r\n    border-radius: 0.4em;\r\n    padding: 1em;\r\n    color: #eee;\r\n  }\r\n\r\n  .svelte-keybinds .dark {\r\n    background: #191c20 !important;\r\n  }\r\n\r\n  .svelte-keybinds .transparent {\r\n    opacity: 0.2 !important;\r\n  }\r\n\r\n  .svelte-keybinds > div {\r\n    height: 4em;\r\n    margin: 0.5em;\r\n    background: #25282c;\r\n    border-radius: 0.4em;\r\n    cursor: pointer;\r\n    transition-property: opacity, transform;\r\n    transition-duration: 0.2s;\r\n    transition-timing-function: ease;\r\n  }\r\n  .svelte-keybinds > div > :global(*) {\r\n    pointer-events: none !important;\r\n  }\r\n  .svelte-keybinds > div:hover {\r\n    transform: scale(0.9);\r\n  }\r\n  .svelte-keybinds .w-50 {\r\n    width: 4em !important;\r\n  }\r\n  .svelte-keybinds .w-75 {\r\n    width: 6.5em !important;\r\n  }\r\n  .svelte-keybinds .w-85 {\r\n    width: 7.5em !important;\r\n  }\r\n  .svelte-keybinds .w-90 {\r\n    width: 8em !important;\r\n  }\r\n  .svelte-keybinds .w-100 {\r\n    width: 9em !important;\r\n  }\r\n  .svelte-keybinds .w-110 {\r\n    width: 10em !important;\r\n  }\r\n  .svelte-keybinds .w-115 {\r\n    width: 10.5em !important;\r\n  }\r\n  .svelte-keybinds .w-300 {\r\n    width: 29em !important;\r\n  }\r\n</style>\r\n","<script>\r\n  import { onMount } from 'svelte'\r\n  import { setFile, speed } from './server.js'\r\n  import Peer from '../../../shared/Peer.js'\r\n  import './File.js'\r\n  import Subtitles from './subtitles.js'\r\n  import { toTS, videoRx } from '../../../shared/util.js'\r\n  import anitomyscript from 'anitomyscript'\r\n  import { URLFile } from '../../../shared/URLFile.js'\r\n  import Keybinds, { loadWithDefaults } from 'svelte-keybinds'\r\n\r\n  export let files = []\r\n  $: updateFiles(files)\r\n  export let name = null\r\n  let src = null\r\n  let video = null\r\n  let container = null\r\n  let current = null\r\n  let subs = null\r\n  let duration = 0.1\r\n  let paused = true\r\n  let muted = false\r\n  let wasPaused = true\r\n  let thumbnail = ' '\r\n  let videos = []\r\n  let immersed = false\r\n  let buffering = false\r\n  let immerseTimeout = null\r\n  let bufferTimeout = null\r\n  let subHeaders = null\r\n  let pip = false\r\n  let presentationRequest = null\r\n  let presentationConnection = null\r\n  let canCast = false\r\n  let isFullscreen = false\r\n  let ended = false\r\n  let volume = localStorage.getItem('volume') || 1\r\n  let playbackRate = 1\r\n  let currentTime = 0\r\n  $: safeduration = (isFinite(duration) ? duration : currentTime) || 0\r\n  $: localStorage.setItem('volume', volume)\r\n  onMount(() => {\r\n    if ('requestVideoFrameCallback' in HTMLVideoElement.prototype) {\r\n      video.addEventListener('loadeddata', () => {\r\n        video.fps = new Promise(resolve => {\r\n          let lastmeta = null\r\n          let count = 0\r\n\r\n          function handleFrames (now, metadata) {\r\n            if (count) {\r\n              // resolve on 2nd frame, 1st frame might be a cut-off\r\n              if (lastmeta) {\r\n                const msbf = (metadata.mediaTime - lastmeta.mediaTime) / (metadata.presentedFrames - lastmeta.presentedFrames)\r\n                const rawFPS = (1 / msbf).toFixed(3)\r\n                // this is accurate for mp4, mkv is a few ms off\r\n                if (current.name.endsWith('.mkv')) {\r\n                  if (rawFPS < 25 && rawFPS > 22) {\r\n                    resolve(23.976)\r\n                  } else if (rawFPS < 31 && rawFPS > 28) {\r\n                    resolve(29.97)\r\n                  } else if (rawFPS < 62 && rawFPS > 58) {\r\n                    resolve(59.94)\r\n                  } else {\r\n                    resolve(rawFPS) // smth went VERY wrong\r\n                  }\r\n                } else {\r\n                  resolve(rawFPS)\r\n                }\r\n              } else {\r\n                lastmeta = metadata\r\n                video.requestVideoFrameCallback(handleFrames)\r\n              }\r\n            } else {\r\n              count++\r\n              paused = false\r\n              video.requestVideoFrameCallback(handleFrames)\r\n            }\r\n          }\r\n          video.requestVideoFrameCallback(handleFrames)\r\n        })\r\n      })\r\n    } else {\r\n      video.fps = 23.976\r\n    }\r\n  })\r\n\r\n  if ('PresentationRequest' in window) {\r\n    const handleAvailability = aval => {\r\n      canCast = !!aval\r\n    }\r\n    presentationRequest = new PresentationRequest(['build/cast.html'])\r\n    presentationRequest.addEventListener('connectionavailable', e => initCast(e))\r\n    navigator.presentation.defaultRequest = presentationRequest\r\n    presentationRequest.getAvailability().then(aval => {\r\n      aval.onchange = e => handleAvailability(e.target.value)\r\n      handleAvailability(aval.value)\r\n    })\r\n  }\r\n\r\n  // document.fullscreenElement isn't reactive\r\n  document.addEventListener('fullscreenchange', () => {\r\n    isFullscreen = !!document.fullscreenElement\r\n  })\r\n\r\n  function handleHeaders () {\r\n    subHeaders = subs?.headers\r\n  }\r\n\r\n  function updateFiles (files) {\r\n    if (files && files.length) {\r\n      videos = files.filter(file => videoRx.test(file.name))\r\n      if (videos?.length) {\r\n        if (!current) {\r\n          handleCurrent(videos[0])\r\n        } else {\r\n          if (subs) {\r\n            subs.files = files || []\r\n            subs.findSubtitleFiles(current)\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  async function handleCurrent (file) {\r\n    if (file) {\r\n      if (thumbnailData.video?.src) URL.revokeObjectURL(video?.src)\r\n      Object.assign(thumbnailData, {\r\n        thumbnails: [],\r\n        interval: undefined,\r\n        video: undefined\r\n      })\r\n      if (file instanceof File || file instanceof URLFile) {\r\n        setFile(file)\r\n        src = `server/${file.name}`\r\n        current = file\r\n        fast = false\r\n      } else {\r\n        setFile(null)\r\n        src = file.url\r\n        current = file\r\n        fast = true\r\n      }\r\n      video?.load()\r\n      initSubs()\r\n    }\r\n  }\r\n  onMount(() => {\r\n    if (!subs) initSubs()\r\n  })\r\n\r\n  function initSubs () {\r\n    if (current && video) {\r\n      if (subs) subs.destroy()\r\n      subs = new Subtitles(video, files, current, handleHeaders)\r\n    }\r\n  }\r\n  function cycleSubtitles () {\r\n    if (current && subs?.headers) {\r\n      const tracks = subs.headers.filter(header => header)\r\n      const index = tracks.indexOf(subs.headers[subs.current]) + 1\r\n      subs.selectCaptions(index >= tracks.length ? -1 : subs.headers.indexOf(tracks[index]))\r\n    }\r\n  }\r\n\r\n  let subDelay = 0\r\n  $: updateDelay(subDelay)\r\n  function updateDelay (delay) {\r\n    if (subs?.renderer) subs.renderer.timeOffset = delay\r\n  }\r\n  $: progress = currentTime / safeduration\r\n  $: targetTime = (!paused && currentTime) || targetTime\r\n  function handleMouseDown ({ target }) {\r\n    wasPaused = paused\r\n    paused = true\r\n    targetTime = target.value * safeduration\r\n  }\r\n  function handleMouseUp () {\r\n    paused = wasPaused\r\n    currentTime = targetTime\r\n  }\r\n  function handleProgress ({ target }) {\r\n    targetTime = target.value * safeduration\r\n  }\r\n\r\n  function playPause () {\r\n    paused = !paused\r\n  }\r\n  function toggleMute () {\r\n    muted = !muted\r\n  }\r\n  function playNext () {\r\n    handleCurrent(videos[(videos.indexOf(current) + 1) % videos.length])\r\n  }\r\n  function playLast () {\r\n    const index = videos.indexOf(current)\r\n    handleCurrent(videos[index === 0 ? videos.length - 1 : index - 1])\r\n  }\r\n  function toggleFullscreen () {\r\n    document.fullscreenElement ? document.exitFullscreen() : container.requestFullscreen()\r\n  }\r\n  function seek (time) {\r\n    if (time === 85 && currentTime < 10) {\r\n      targetTime = currentTime = 90\r\n    } else if (time === 85 && safeduration - currentTime < 90) {\r\n      targetTime = currentTime = safeduration\r\n    } else {\r\n      targetTime = currentTime += time\r\n    }\r\n  }\r\n  function forward () {\r\n    seek(2)\r\n  }\r\n  function rewind () {\r\n    seek(-2)\r\n  }\r\n  function selectAudio (id) {\r\n    if (id !== undefined) {\r\n      for (const track of video.audioTracks) {\r\n        track.enabled = track.id === id\r\n      }\r\n      seek(-0.2) // stupid fix because video freezes up when chaging tracks\r\n    }\r\n  }\r\n  function selectVideo (id) {\r\n    if (id !== undefined) {\r\n      for (const track of video.videoTracks) {\r\n        track.selected = track.id === id\r\n      }\r\n    }\r\n  }\r\n  function toggleCast () {\r\n    if (video.readyState) {\r\n      if (presentationConnection) {\r\n        presentationConnection?.terminate()\r\n      } else {\r\n        presentationRequest.start()\r\n      }\r\n    }\r\n  }\r\n  async function screenshot () {\r\n    if ('clipboard' in navigator) {\r\n      const canvas = document.createElement('canvas')\r\n      const context = canvas.getContext('2d')\r\n      canvas.width = video.videoWidth\r\n      canvas.height = video.videoHeight\r\n      context.drawImage(video, 0, 0)\r\n      if (subs?.renderer) {\r\n        subs.renderer.resize(video.videoWidth, video.videoHeight)\r\n        await new Promise(resolve => subs.renderer._worker.addEventListener('message', () => setTimeout(resolve, 50), { once: true }))\r\n        context.drawImage(subs.renderer._canvas, 0, 0, canvas.width, canvas.height)\r\n        subs.renderer.resize(0, 0, 0, 0) // undo resize\r\n      }\r\n      const blob = await new Promise(resolve => canvas.toBlob(resolve))\r\n      await navigator.clipboard.write([\r\n        new ClipboardItem({\r\n          [blob.type]: blob\r\n        })\r\n      ])\r\n      canvas.remove()\r\n    }\r\n  }\r\n  function togglePopout () {\r\n    if (video.readyState) {\r\n      if (!subs?.renderer) {\r\n        if (video !== document.pictureInPictureElement) {\r\n          video.requestPictureInPicture()\r\n          pip = true\r\n        } else {\r\n          document.exitPictureInPicture()\r\n          pip = false\r\n        }\r\n      } else {\r\n        if (document.pictureInPictureElement && !document.pictureInPictureElement.id) {\r\n          // only exit if pip is the custom one, else overwrite existing pip with custom\r\n          document.exitPictureInPicture()\r\n          pip = false\r\n        } else {\r\n          const canvasVideo = document.createElement('video')\r\n          const { stream, destroy } = getBurnIn()\r\n          const cleanup = () => {\r\n            pip = false\r\n            destroy()\r\n            canvasVideo.remove()\r\n          }\r\n          pip = true\r\n          canvasVideo.srcObject = stream\r\n          canvasVideo.onloadedmetadata = () => {\r\n            canvasVideo.play()\r\n            if (pip) {\r\n              canvasVideo.requestPictureInPicture().catch(e => {\r\n                cleanup()\r\n                console.warn('Failed To Burn In Subtitles ' + e)\r\n              })\r\n            } else {\r\n              cleanup()\r\n            }\r\n          }\r\n          canvasVideo.onleavepictureinpicture = cleanup\r\n        }\r\n      }\r\n    }\r\n  }\r\n  let showKeybinds = false\r\n  loadWithDefaults({\r\n    KeyX: {\r\n      fn: () => screenshot(),\r\n      id: 'screenshot_monitor',\r\n      type: 'icon'\r\n    },\r\n    KeyR: {\r\n      fn: () => seek(-90),\r\n      id: '-90'\r\n    },\r\n    Comma: {\r\n      fn: async () => seek(-1 / (await video.fps) || 0),\r\n      id: 'fast_rewind',\r\n      type: 'icon'\r\n    },\r\n    Period: {\r\n      fn: async () => seek(1 / (await video.fps) || 0),\r\n      id: 'fast_forward',\r\n      type: 'icon'\r\n    },\r\n    KeyI: {\r\n      fn: () => toggleStats(),\r\n      id: 'list',\r\n      type: 'icon'\r\n    },\r\n    Backquote: {\r\n      fn: () => (showKeybinds = !showKeybinds),\r\n      id: 'help_outline',\r\n      type: 'icon'\r\n    },\r\n    Space: {\r\n      fn: () => playPause(),\r\n      id: 'play_arrow',\r\n      type: 'icon'\r\n    },\r\n    KeyN: {\r\n      fn: () => playNext(),\r\n      id: 'skip_next',\r\n      type: 'icon'\r\n    },\r\n    KeyM: {\r\n      fn: () => (muted = !muted),\r\n      id: 'volume_off',\r\n      type: 'icon'\r\n    },\r\n    KeyP: {\r\n      fn: () => togglePopout(),\r\n      id: 'picture_in_picture',\r\n      type: 'icon'\r\n    },\r\n    KeyF: {\r\n      fn: () => toggleFullscreen(),\r\n      id: 'fullscreen',\r\n      type: 'icon'\r\n    },\r\n    KeyS: {\r\n      fn: () => seek(85),\r\n      id: '+90'\r\n    },\r\n    KeyD: {\r\n      fn: () => toggleCast(),\r\n      id: 'cast',\r\n      type: 'icon'\r\n    },\r\n    KeyC: {\r\n      fn: () => cycleSubtitles(),\r\n      id: 'subtitles',\r\n      type: 'icon'\r\n    },\r\n    ArrowLeft: {\r\n      fn: () => rewind(),\r\n      id: '-2'\r\n    },\r\n    ArrowRight: {\r\n      fn: () => forward(),\r\n      id: '+2'\r\n    },\r\n    ArrowUp: {\r\n      fn: () => (volume = Math.min(1, volume + 0.05)),\r\n      id: 'volume_up',\r\n      type: 'icon'\r\n    },\r\n    ArrowDown: {\r\n      fn: () => (volume = Math.max(0, volume - 0.05)),\r\n      id: 'volume_down',\r\n      type: 'icon'\r\n    },\r\n    BracketLeft: {\r\n      fn: () => (playbackRate -= 0.1),\r\n      id: 'history',\r\n      type: 'icon'\r\n    },\r\n    BracketRight: {\r\n      fn: () => (playbackRate += 0.1),\r\n      id: 'update',\r\n      type: 'icon'\r\n    },\r\n    Backslash: {\r\n      fn: () => (playbackRate = 1),\r\n      id: 'schedule',\r\n      type: 'icon'\r\n    }\r\n  })\r\n\r\n  function getBurnIn (noSubs) {\r\n    const canvas = document.createElement('canvas')\r\n    const context = canvas.getContext('2d')\r\n    let loop = null\r\n    canvas.width = video.videoWidth\r\n    canvas.height = video.videoHeight\r\n    if (!noSubs) subs.renderer.resize(video.videoWidth, video.videoHeight)\r\n    const renderFrame = () => {\r\n      context.drawImage(video, 0, 0)\r\n      if (!noSubs) context.drawImage(subs.renderer?._canvas, 0, 0, canvas.width, canvas.height)\r\n      loop = video.requestVideoFrameCallback(renderFrame)\r\n    }\r\n    renderFrame()\r\n    const destroy = () => {\r\n      if (!noSubs) subs.renderer.resize()\r\n      video.cancelVideoFrameCallback(loop)\r\n      canvas.remove()\r\n    }\r\n\r\n    return { stream: canvas.captureStream(), destroy }\r\n  }\r\n\r\n  function initCast (event) {\r\n    // these quality settings are likely to make cast overheat, oh noes!\r\n    let peer = new Peer({\r\n      polite: true,\r\n      quality: {\r\n        audio: {\r\n          stereo: 1,\r\n          'sprop-stereo': 1,\r\n          maxaveragebitrate: 510000,\r\n          maxplaybackrate: 510000,\r\n          cbr: 0,\r\n          useinbandfec: 1,\r\n          usedtx: 1,\r\n          maxptime: 20,\r\n          minptime: 10\r\n        },\r\n        video: {\r\n          bitrate: 2000000,\r\n          codecs: ['VP9', 'VP8', 'H264']\r\n        }\r\n      }\r\n    })\r\n\r\n    presentationConnection = event.connection\r\n    presentationConnection.addEventListener('terminate', () => {\r\n      presentationConnection = null\r\n      peer = null\r\n    })\r\n\r\n    peer.signalingPort.onmessage = ({ data }) => {\r\n      presentationConnection.send(data)\r\n    }\r\n\r\n    presentationConnection.addEventListener('message', ({ data }) => {\r\n      peer.signalingPort.postMessage(data)\r\n    })\r\n\r\n    peer.dc.onopen = () => {\r\n      if (peer && presentationConnection) {\r\n        const tracks = []\r\n        const videostream = video.captureStream()\r\n        if (true) {\r\n          // TODO: check if cast supports codecs\r\n          const { stream, destroy } = getBurnIn(!subs?.renderer)\r\n          tracks.push(stream.getVideoTracks()[0], videostream.getAudioTracks()[0])\r\n          presentationConnection.addEventListener('terminate', destroy)\r\n        } else {\r\n          tracks.push(videostream.getVideoTracks()[0], videostream.getAudioTracks()[0])\r\n        }\r\n        for (const track of tracks) {\r\n          peer.pc.addTrack(track, videostream)\r\n        }\r\n        paused = false // video pauses for some reason\r\n      }\r\n    }\r\n  }\r\n\r\n  function immersePlayer () {\r\n    immersed = true\r\n    immerseTimeout = undefined\r\n  }\r\n\r\n  function resetImmerse () {\r\n    if (immerseTimeout) {\r\n      clearTimeout(immerseTimeout)\r\n    } else {\r\n      immersed = false\r\n    }\r\n    immerseTimeout = setTimeout(immersePlayer, 8 * 1000)\r\n  }\r\n\r\n  function hideBuffering () {\r\n    if (bufferTimeout) {\r\n      clearTimeout(bufferTimeout)\r\n      bufferTimeout = null\r\n      buffering = false\r\n    }\r\n  }\r\n\r\n  function showBuffering () {\r\n    bufferTimeout = setTimeout(() => {\r\n      buffering = true\r\n      resetImmerse()\r\n    }, 150)\r\n  }\r\n  $: navigator.mediaSession?.setPositionState({\r\n    duration: Math.max(0, safeduration),\r\n    playbackRate: 1,\r\n    position: Math.max(0, Math.min(safeduration, currentTime || 0))\r\n  })\r\n  \r\n  async function mediaChange (current, image) {\r\n    if (current) {\r\n      const { release_group, anime_title, episode_number, episode_title } = await anitomyscript(current.name)\r\n      // honestly, this is made for anime, but works fantastic for everything else.\r\n      name = [anime_title, episode_number, episode_title].filter(i => i).join(' - ')\r\n      if ('mediaSession' in navigator) {\r\n        const metadata = image\r\n          ? new MediaMetadata({\r\n            title: name || 'Video Player',\r\n            artwork: [\r\n              {\r\n                src: image,\r\n                sizes: '256x256',\r\n                type: 'image/jpg'\r\n              }\r\n            ]\r\n          })\r\n          : new MediaMetadata({\r\n            title: name || 'Video Player'\r\n          })\r\n        if (release_group) metadata.artist = release_group\r\n        navigator.mediaSession.metadata = metadata\r\n      }\r\n    }\r\n  }\r\n  $: mediaChange(current)\r\n\r\n  if ('mediaSession' in navigator) {\r\n    navigator.mediaSession.setActionHandler('play', playPause)\r\n    navigator.mediaSession.setActionHandler('pause', playPause)\r\n    navigator.mediaSession.setActionHandler('nexttrack', playNext)\r\n    navigator.mediaSession.setActionHandler('previoustrack', playLast)\r\n    navigator.mediaSession.setActionHandler('seekforward', forward)\r\n    navigator.mediaSession.setActionHandler('seekbackward', rewind)\r\n  }\r\n  let stats = null\r\n  let requestCallback = null\r\n  function toggleStats () {\r\n    if ('requestVideoFrameCallback' in HTMLVideoElement.prototype) {\r\n      if (requestCallback) {\r\n        stats = null\r\n        video.cancelVideoFrameCallback(requestCallback)\r\n        requestCallback = null\r\n      } else {\r\n        requestCallback = video.requestVideoFrameCallback((a, b) => {\r\n          stats = {}\r\n          handleStats(a, b, b)\r\n        })\r\n      }\r\n    }\r\n  }\r\n  async function handleStats (now, metadata, lastmeta) {\r\n    if (stats) {\r\n      const msbf = (metadata.mediaTime - lastmeta.mediaTime) / (metadata.presentedFrames - lastmeta.presentedFrames)\r\n      const fps = (1 / msbf).toFixed(3)\r\n      stats = {\r\n        fps,\r\n        presented: metadata.presentedFrames,\r\n        dropped: video.getVideoPlaybackQuality()?.droppedVideoFrames,\r\n        processing: metadata.processingDuration + ' ms',\r\n        viewport: video.clientWidth + 'x' + video.clientHeight,\r\n        resolution: videoWidth + 'x' + videoHeight,\r\n        buffer: getBufferHealth(metadata.mediaTime) + ' s',\r\n        speed: video.playbackRate || 1\r\n      }\r\n      setTimeout(() => video.requestVideoFrameCallback((n, m) => handleStats(n, m, metadata)), 200)\r\n    }\r\n  }\r\n  function getBufferHealth (time) {\r\n    for (let index = video.buffered.length; index--;) {\r\n      if (time < video.buffered.end(index) && time > video.buffered.start(index)) {\r\n        return parseInt(video.buffered.end(index) - time)\r\n      }\r\n    }\r\n    return 0\r\n  }\r\n  let fast = false\r\n  let successCount = 0\r\n  async function checkSpeed () {\r\n    if (!fast && (current instanceof File || current instanceof URLFile) && safeduration) {\r\n      const byterate = current.size / safeduration\r\n      const currBps = speed()\r\n      if (currBps > 5 * byterate) {\r\n        ++successCount\r\n        // this is faulty logic, because there might not be a need to pull data, even if the speeds can be reached\r\n        if (successCount > 10) {\r\n          console.log('Access speed exceeds x5 bitrate')\r\n          fast = true\r\n          await subs?.parseSubtitles()\r\n          finishThumbnails()\r\n        }\r\n      } else {\r\n        successCount = 0\r\n      }\r\n    }\r\n  }\r\n  const thumbCanvas = document.createElement('canvas')\r\n  thumbCanvas.width = 200\r\n  const thumbnailData = {\r\n    thumbnails: [],\r\n    canvas: thumbCanvas,\r\n    context: thumbCanvas.getContext('2d'),\r\n    interval: null,\r\n    video: null\r\n  }\r\n  let hover = null\r\n  let hoverTime = 0\r\n  let hoverOffset = 0\r\n  function handleHover ({ offsetX, target }) {\r\n    hoverOffset = offsetX / target.clientWidth\r\n    hoverTime = safeduration * hoverOffset\r\n    hover.style.setProperty('left', hoverOffset * 100 + '%')\r\n    thumbnail = thumbnailData.thumbnails[Math.floor(hoverTime / thumbnailData.interval)] || ' '\r\n  }\r\n  function createThumbnail (vid = video) {\r\n    if (vid?.readyState >= 2 && (current instanceof File || current instanceof URLFile)) {\r\n      const index = Math.floor(vid.currentTime / thumbnailData.interval)\r\n      if (!thumbnailData.thumbnails[index]) {\r\n        thumbnailData.context.fillRect(0, 0, 200, thumbnailData.canvas.height)\r\n        thumbnailData.context.drawImage(vid, 0, 0, 200, thumbnailData.canvas.height)\r\n        thumbnailData.thumbnails[index] = thumbnailData.canvas.toDataURL('image/jpeg')\r\n        if (index === 5) mediaChange(current, thumbnailData.thumbnails[index])\r\n      }\r\n    }\r\n  }\r\n  let videoWidth, videoHeight\r\n  $: initThumbnails(200 / (videoWidth / videoHeight))\r\n  function initThumbnails (height) {\r\n    if (!isNaN(height)) {\r\n      thumbnailData.interval = safeduration / 300 < 5 ? 5 : safeduration / 300\r\n      thumbnailData.canvas.height = height\r\n    }\r\n  }\r\n\r\n  function finishThumbnails () {\r\n    const t0 = performance.now()\r\n    const video = document.createElement('video')\r\n    let index = 0\r\n    video.preload = 'none'\r\n    video.volume = 0\r\n    video.playbackRate = 0\r\n    video.addEventListener('loadeddata', () => loadTime())\r\n    video.addEventListener('canplay', () => {\r\n      createThumbnail(thumbnailData.video)\r\n      loadTime()\r\n    })\r\n    thumbnailData.video = video\r\n    const loadTime = () => {\r\n      while (thumbnailData.thumbnails[index] && index <= Math.floor(safeduration / thumbnailData.interval)) {\r\n        // only create thumbnails that are missing\r\n        index++\r\n      }\r\n      if (thumbnailData.video?.currentTime !== safeduration && thumbnailData.video) {\r\n        thumbnailData.video.currentTime = index * thumbnailData.interval\r\n      } else {\r\n        thumbnailData.video?.removeAttribute('src')\r\n        thumbnailData.video?.load()\r\n        thumbnailData.video?.remove()\r\n        delete thumbnailData.video\r\n        console.log('Thumbnail creating finished', index, toTS((performance.now() - t0) / 1000))\r\n      }\r\n      index++\r\n    }\r\n    thumbnailData.video.src = current instanceof File ? URL.createObjectURL(current) : current.url\r\n    thumbnailData.video.load()\r\n    console.log('Thumbnail creating started')\r\n  }\r\n  let isStandalone = window.matchMedia('(display-mode: standalone)').matches\r\n  window.matchMedia('(display-mode: standalone)').addEventListener('change', ({ matches }) => {\r\n    isStandalone = matches\r\n  })\r\n  const isWindows = navigator.appVersion.includes('Windows')\r\n  let innerWidth, innerHeight\r\n  let menubarOffset = 0\r\n  $: calcMenubarOffset(innerWidth, innerHeight, videoWidth, videoHeight, isStandalone)\r\n  function calcMenubarOffset (innerWidth, innerHeight, videoWidth, videoHeight, isStandalone) {\r\n    // outerheight resize and innerheight resize is mutual, additionally update on metadata and app state change\r\n    if (isStandalone && videoWidth && videoHeight) {\r\n      // so windows is very dumb, and calculates windowed mode as if it was window XP, with the old bars, but not when maximised\r\n      const isMaximised = screen.availWidth === window.outerWidth && screen.availHeight === window.outerHeight\r\n      const menubar = Math.max(0, isWindows && !isMaximised ? window.outerHeight - innerHeight - 8 : window.outerHeight - innerHeight)\r\n      // element ratio calc\r\n      const videoRatio = videoWidth / videoHeight\r\n      const { offsetWidth, offsetHeight } = video\r\n      const elementRatio = offsetWidth / offsetHeight\r\n      // video is shorter than element && has space for menubar offset\r\n      if (!document.fullscreenElement && menubar && elementRatio <= videoRatio && offsetHeight - offsetWidth / videoRatio > menubar) {\r\n        menubarOffset = (menubar / 2) * -1\r\n      } else {\r\n        menubarOffset = 0\r\n      }\r\n    }\r\n  }\r\n</script>\r\n\r\n<svelte:window bind:innerWidth bind:innerHeight />\r\n{#if showKeybinds}\r\n  <div class=\"position-absolute bg-tp w-full h-full z-50 font-size-12 p-20 d-flex align-items-center justify-content-center\" on:click|self={() => (showKeybinds = false)}>\r\n    <button class=\"close\" type=\"button\" on:click={() => (showKeybinds = false)}><span>×</span></button>\r\n    <Keybinds let:prop={item} autosave={true} clickable={true}>\r\n      <div class:material-icons={item?.type} class=\"bind\">{item?.id || ''}</div>\r\n    </Keybinds>\r\n  </div>\r\n{/if}\r\n<!-- svelte-ignore a11y-media-has-caption -->\r\n<div\r\n  class=\"player w-full h-full d-flex flex-column\"\r\n  class:pip\r\n  class:immersed\r\n  class:buffering\r\n  bind:this={container}\r\n  on:mousemove={resetImmerse}\r\n  on:touchmove={resetImmerse}\r\n  on:keypress={resetImmerse}\r\n  on:mouseleave={immersePlayer}>\r\n  <video\r\n    class=\"position-absolute h-full w-full\"\r\n    style={`margin-top: ${menubarOffset}px`}\r\n    autoplay\r\n    preload=\"auto\"\r\n    {src}\r\n    bind:videoHeight\r\n    bind:videoWidth\r\n    bind:this={video}\r\n    bind:volume\r\n    bind:duration\r\n    bind:currentTime\r\n    bind:paused\r\n    bind:ended\r\n    bind:muted\r\n    bind:playbackRate\r\n    on:timeupdate={checkSpeed}\r\n    on:timeupdate={() => createThumbnail()}\r\n    on:waiting={showBuffering}\r\n    on:loadeddata={hideBuffering}\r\n    on:canplay={hideBuffering}\r\n    on:playing={hideBuffering}\r\n    on:loadedmetadata={hideBuffering}\r\n    on:leavepictureinpicture={() => (pip = false)} />\r\n  {#if stats}\r\n    <div class=\"position-absolute top-0 bg-tp p-10 m-15 text-monospace rounded z-50\">\r\n      <button class=\"close\" type=\"button\" on:click={toggleStats}><span>×</span></button>\r\n      FPS: {stats.fps}<br />\r\n      Presented frames: {stats.presented}<br />\r\n      Dropped frames: {stats.dropped}<br />\r\n      Frame time: {stats.processing}<br />\r\n      Viewport: {stats.viewport}<br />\r\n      Resolution: {stats.resolution}<br />\r\n      Buffer health: {stats.buffer}<br />\r\n      Playback speed: x{stats.speed?.toFixed(1)}\r\n    </div>\r\n  {/if}\r\n  <div class=\"top z-40 d-flex flex-row-reverse\">\r\n    <span class=\"material-icons ctrl font-size-12 p-10\" title=\"Keybinds [`]\" data-name=\"togglePopout\" on:click={() => (showKeybinds = true)}> help_outline </span>\r\n  </div>\r\n  <div class=\"middle d-flex align-items-center justify-content-center flex-grow-1 z-40 position-relative\">\r\n    <div class=\"position-absolute w-full h-full\" on:dblclick={toggleFullscreen}>\r\n      <div class=\"play-overlay w-full h-full\" on:click={playPause} />\r\n    </div>\r\n    {#if videos?.length > 1}\r\n      <span class=\"material-icons ctrl\" data-name=\"playLast\" on:click={playLast}> skip_previous </span>\r\n    {/if}\r\n    <span class=\"material-icons ctrl\" data-name=\"rewind\" on:click={rewind}> fast_rewind </span>\r\n    <span class=\"material-icons ctrl\" data-name=\"playPause\" on:click={playPause}> {ended ? 'replay' : paused ? 'play_arrow' : 'pause'} </span>\r\n    <span class=\"material-icons ctrl\" data-name=\"forward\" on:click={forward}> fast_forward </span>\r\n    {#if videos?.length > 1}\r\n      <span class=\"material-icons ctrl\" data-name=\"playNext\" on:click={playNext}> skip_next </span>\r\n    {/if}\r\n    <div data-name=\"bufferingDisplay\" class=\"position-absolute\" />\r\n  </div>\r\n  <div class=\"bottom d-flex z-40\">\r\n    <span class=\"material-icons ctrl\" title=\"Play/Pause [Space]\" data-name=\"playPause\" on:click={playPause}> {ended ? 'replay' : paused ? 'play_arrow' : 'pause'} </span>\r\n    {#if videos?.length > 1}\r\n      <span class=\"material-icons ctrl\" title=\"Next [N]\" data-name=\"playNext\" on:click={playNext}> skip_next </span>\r\n    {/if}\r\n    <div class=\"d-flex w-auto volume\">\r\n      <span class=\"material-icons ctrl\" title=\"Mute [M]\" data-name=\"toggleMute\" on:click={toggleMute}> {muted ? 'volume_off' : 'volume_up'} </span>\r\n      <input class=\"ctrl\" type=\"range\" min=\"0\" max=\"1\" step=\"any\" data-name=\"setVolume\" bind:value={volume} style=\"--value: {volume * 100}%\" />\r\n    </div>\r\n    <!-- svelte-ignore missing-declaration -->\r\n    {#if 'audioTracks' in HTMLVideoElement.prototype && video?.audioTracks?.length > 1}\r\n      <div class=\"dropdown dropup with-arrow\">\r\n        <span class=\"material-icons ctrl\" title=\"Audio Tracks\" id=\"baudio\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\" data-name=\"audioButton\">\r\n          queue_music\r\n        </span>\r\n        <div class=\"dropdown-menu dropdown-menu-left ctrl custom-radio p-10 pb-5 text-capitalize\" aria-labelledby=\"baudio\" data-name=\"selectAudio\">\r\n          {#each video.audioTracks as track}\r\n            <input name=\"audio-radio-set\" type=\"radio\" id=\"audio-{track.id}-radio\" value={track.id} checked={track.enabled} />\r\n            <label for=\"audio-{track.id}-radio\" on:click={() => selectAudio(track.id)} class=\"text-truncate pb-5\">\r\n              {(track.language || (!Object.values(video.audioTracks).some(track => track.language === 'eng' || track.language === 'en') ? 'eng' : track.label)) +\r\n                (track.label ? ' - ' + track.label : '')}</label>\r\n          {/each}\r\n        </div>\r\n      </div>\r\n    {/if}\r\n    <!-- svelte-ignore missing-declaration -->\r\n    {#if 'videoTracks' in HTMLVideoElement.prototype && video?.videoTracks?.length > 1}\r\n    <div class=\"dropdown dropup with-arrow\">\r\n      <span class=\"material-icons ctrl\" title=\"Video Tracks\" id=\"bvideo\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\" data-name=\"videoButton\">\r\n        playlist_play\r\n      </span>\r\n      <div class=\"dropdown-menu dropdown-menu-left ctrl custom-radio p-10 pb-5 text-capitalize\" aria-labelledby=\"bvideo\" data-name=\"selectVideo\">\r\n        {#each video.videoTracks as track}\r\n          <input name=\"video-radio-set\" type=\"radio\" id=\"video-{track.id}-radio\" value={track.id} checked={track.selected} />\r\n          <label for=\"video-{track.id}-radio\" on:click={() => selectVideo(track.id)} class=\"text-truncate pb-5\">\r\n            {(track.language || (!Object.values(video.videoTracks).some(track => track.language === 'eng' || track.language === 'en') ? 'eng' : track.label)) +\r\n              (track.label ? ' - ' + track.label : '')}</label>\r\n        {/each}\r\n      </div>\r\n    </div>\r\n  {/if}\r\n    <div class=\"w-full d-flex align-items-center\" data-name=\"progressWrapper\">\r\n      <div class=\"ts\">{toTS(targetTime, safeduration > 3600 ? 2 : 3)}</div>\r\n      <div class=\"w-full h-full position-relative\">\r\n        <input\r\n          class=\"ctrl w-full h-full\"\r\n          type=\"range\"\r\n          min=\"0\"\r\n          max=\"1\"\r\n          step=\"any\"\r\n          data-name=\"setProgress\"\r\n          bind:value={progress}\r\n          on:mousedown={handleMouseDown}\r\n          on:mouseup={handleMouseUp}\r\n          on:mousemove={handleHover}\r\n          on:input={handleProgress}\r\n          on:touchstart={handleMouseDown}\r\n          on:touchend={handleMouseUp}\r\n          style=\"--value: {progress * 100}%\" />\r\n        <div class=\"hover position-absolute d-flex flex-column align-items-center\" bind:this={hover}>\r\n          <img alt=\"thumbnail\" class=\"w-full mb-5 shadow-lg\" src={thumbnail} />\r\n          <div class=\"ts\">{toTS(hoverTime)}</div>\r\n        </div>\r\n      </div>\r\n      <div class=\"ts\">{toTS(safeduration - targetTime, safeduration > 3600 ? 2 : 3)}</div>\r\n    </div>\r\n    {#if subHeaders?.length}\r\n      <div class=\"subtitles dropdown dropup with-arrow\">\r\n        <span class=\"material-icons ctrl\" title=\"Subtitles [C]\" id=\"bcap\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\" data-name=\"captionsButton\">\r\n          subtitles\r\n        </span>\r\n        <div class=\"dropdown-menu dropdown-menu-right ctrl custom-radio p-10 pb-5 text-capitalize w-200\" aria-labelledby=\"bcap\" data-name=\"selectCaptions\">\r\n          <input name=\"subtitle-radio-set\" type=\"radio\" id=\"subtitle-off-radio\" value=\"off\" checked={subHeaders && subs?.current === -1} />\r\n          <label for=\"subtitle-off-radio\" on:click={() => subs.selectCaptions(-1)} class=\"text-truncate pb-5\"> OFF </label>\r\n          {#each subHeaders as track}\r\n            {#if track}\r\n              <input name=\"subtitle-radio-set\" type=\"radio\" id=\"subtitle-{track.number}-radio\" value={track.numer} checked={track.number === subs.current} />\r\n              <label for=\"subtitle-{track.nubmer}-radio\" on:click={() => subs.selectCaptions(track.number)} class=\"text-truncate pb-5\">\r\n                {(track.language || (!Object.values(subs.headers).some(header => header.language === 'eng' || header.language === 'en') ? 'eng' : track.type)) +\r\n                  (track.name ? ' - ' + track.name : '')}\r\n              </label>\r\n            {/if}\r\n          {/each}\r\n          <input type=\"number\" step=\"0.1\" bind:value={subDelay} class=\"form-control text-right form-control-sm\" />\r\n        </div>\r\n      </div>\r\n    {/if}\r\n    <!-- svelte-ignore missing-declaration -->\r\n    {#if 'PresentationRequest' in window && canCast && (!current || current instanceof File || current instanceof URLFile)}\r\n      <span class=\"material-icons ctrl\" title=\"Cast Video [D]\" data-name=\"toggleCast\" on:click={toggleCast}>\r\n        {presentationConnection ? 'cast_connected' : 'cast'}\r\n      </span>\r\n    {/if}\r\n    {#if 'pictureInPictureEnabled' in document}\r\n      <span class=\"material-icons ctrl\" title=\"Popout Window [P]\" data-name=\"togglePopout\" on:click={togglePopout}>\r\n        {pip ? 'featured_video' : 'picture_in_picture'}\r\n      </span>\r\n    {/if}\r\n    <span class=\"material-icons ctrl\" title=\"Fullscreen [F]\" data-name=\"toggleFullscreen\" on:click={toggleFullscreen}>\r\n      {isFullscreen ? 'fullscreen_exit' : 'fullscreen'}\r\n    </span>\r\n  </div>\r\n</div>\r\n\r\n<style>\r\n  .bind {\r\n    font-size: 1.8rem;\r\n    font-weight: bold;\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n    height: 100%;\r\n  }\r\n  .bind.material-icons {\r\n    font-size: 2.2rem !important;\r\n    font-weight: unset !important;\r\n  }\r\n  .bg-tp {\r\n    background: #000000bb;\r\n    backdrop-filter: blur(10px);\r\n  }\r\n  .bg-tp .close {\r\n    position: absolute;\r\n    top: 0;\r\n    right: 0;\r\n    cursor: pointer;\r\n    color: inherit;\r\n    padding: var(--alert-close-padding);\r\n    line-height: var(--alert-close-line-height);\r\n    font-size: var(--alert-close-font-size);\r\n    background-color: transparent;\r\n    border-color: transparent;\r\n  }\r\n\r\n  video {\r\n    transition: margin-top 0.2s ease;\r\n  }\r\n  .player {\r\n    user-select: none;\r\n    font-family: Roboto, Arial, Helvetica, sans-serif;\r\n    transition: width 0.2s ease;\r\n    background: #000;\r\n  }\r\n\r\n  .pip :global(canvas) {\r\n    left: 99.9% !important;\r\n    /*hack to hide the canvas but still keep it updating*/\r\n  }\r\n\r\n  .material-icons {\r\n    font-size: 2.2rem;\r\n    padding: 1.2rem;\r\n    transition: all 0.2s ease;\r\n    display: flex;\r\n  }\r\n\r\n  .immersed {\r\n    cursor: none;\r\n  }\r\n\r\n  .immersed .middle .ctrl,\r\n  .immersed .top,\r\n  .immersed .bottom {\r\n    opacity: 0;\r\n  }\r\n\r\n  .bottom img[src=' '],\r\n  :fullscreen .ctrl[data-name='toggleCast'],\r\n  :fullscreen .ctrl[data-name='togglePopout'] {\r\n    display: none !important;\r\n  }\r\n\r\n  .pip video {\r\n    visibility: hidden;\r\n  }\r\n\r\n  .middle div[data-name='bufferingDisplay'] {\r\n    border: 4px solid #ffffff00;\r\n    border-top: 4px solid #fff;\r\n    border-radius: 50%;\r\n    width: 40px;\r\n    height: 40px;\r\n    animation: spin 1s linear infinite;\r\n    opacity: 0;\r\n    transition: 0.5s opacity ease;\r\n    filter: drop-shadow(0 0 8px #000);\r\n  }\r\n\r\n  .buffering .middle div[data-name='bufferingDisplay'] {\r\n    opacity: 1 !important;\r\n  }\r\n\r\n  @keyframes spin {\r\n    0% {\r\n      transform: rotate(0deg);\r\n    }\r\n\r\n    100% {\r\n      transform: rotate(360deg);\r\n    }\r\n  }\r\n\r\n  .middle .ctrl {\r\n    font-size: 4rem;\r\n    margin: 2rem;\r\n    z-index: 3;\r\n    display: none;\r\n  }\r\n\r\n  :fullscreen {\r\n    background: #000 !important;\r\n  }\r\n\r\n  @media (pointer: none), (pointer: coarse) {\r\n    .middle .ctrl {\r\n      display: flex;\r\n    }\r\n    .middle .play-overlay {\r\n      display: none !important;\r\n    }\r\n  }\r\n\r\n  .middle .ctrl[data-name='playPause'] {\r\n    font-size: 6rem;\r\n  }\r\n\r\n  .middle .ctrl,\r\n  .bottom .ctrl:hover,\r\n  .bottom .ts:hover,\r\n  .bottom .hover .ts {\r\n    filter: drop-shadow(0 0 8px #000);\r\n  }\r\n\r\n  .bottom {\r\n    background: linear-gradient(to top, rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0.4) 25%, rgba(0, 0, 0, 0.2) 50%, rgba(0, 0, 0, 0.1) 75%, transparent);\r\n    transition: 0.5s opacity ease;\r\n  }\r\n  .top {\r\n    background: linear-gradient(to bottom, rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0.4) 25%, rgba(0, 0, 0, 0.2) 50%, rgba(0, 0, 0, 0.1) 75%, transparent);\r\n    transition: 0.5s opacity ease;\r\n  }\r\n\r\n  .ctrl {\r\n    cursor: pointer;\r\n  }\r\n\r\n  input[type='range'] {\r\n    -webkit-appearance: none;\r\n    background: transparent;\r\n    margin: 0;\r\n    cursor: pointer;\r\n    height: 8px;\r\n  }\r\n\r\n  input[type='range']:focus {\r\n    outline: none;\r\n  }\r\n\r\n  input[type='range']::-webkit-slider-runnable-track {\r\n    height: 3px;\r\n  }\r\n\r\n  input[type='range']::-moz-range-track {\r\n    height: 3px;\r\n    border: none;\r\n  }\r\n\r\n  input[type='range']::-webkit-slider-thumb {\r\n    height: 0;\r\n    width: 0;\r\n    border-radius: 50%;\r\n    background: #ff3c00;\r\n    -webkit-appearance: none;\r\n    appearance: none;\r\n    transition: all 0.1s ease;\r\n  }\r\n  input[type='range']::-moz-range-thumb {\r\n    height: 0;\r\n    width: 0;\r\n    border-radius: 50%;\r\n    background: #ff3c00;\r\n    -webkit-appearance: none;\r\n    appearance: none;\r\n    transition: all 0.1s ease;\r\n    border: none;\r\n  }\r\n\r\n  input[type='range']:hover::-webkit-slider-thumb {\r\n    height: 12px;\r\n    width: 12px;\r\n    margin-top: -4px;\r\n  }\r\n\r\n  input[type='range']:hover::-moz-range-thumb {\r\n    height: 12px;\r\n    width: 12px;\r\n    margin-top: -4px;\r\n  }\r\n\r\n  input[type='range']::-moz-range-track {\r\n    background: linear-gradient(90deg, #ff3c00 var(--value), rgba(255, 255, 255, 0.2) var(--value));\r\n  }\r\n  input[type='range']::-webkit-slider-runnable-track {\r\n    background: linear-gradient(90deg, #ff3c00 var(--value), rgba(255, 255, 255, 0.2) var(--value));\r\n  }\r\n  .bottom .volume:hover input[type='range'] {\r\n    width: 5vw;\r\n    display: inline-block;\r\n    transition: all 0.1s ease;\r\n    margin-right: 1rem;\r\n  }\r\n\r\n  .bottom .volume input[type='range'] {\r\n    width: 0;\r\n    transition: all 0.1s ease;\r\n    height: 100%;\r\n  }\r\n\r\n  .bottom [data-name='setProgress'] ~ .hover {\r\n    pointer-events: none;\r\n    opacity: 0;\r\n    top: 1.2rem;\r\n    transform: translate(-50%, -100%);\r\n    position: absolute;\r\n    font-family: Roboto, Arial, Helvetica, sans-serif;\r\n    white-space: nowrap;\r\n    font-weight: 600;\r\n    width: 200px;\r\n    transition: 0.2s opacity ease;\r\n  }\r\n\r\n  .bottom [data-name='setProgress']:hover ~ .hover {\r\n    opacity: 1;\r\n  }\r\n\r\n  .bottom div[data-name='progressWrapper'] .ts {\r\n    color: #ececec;\r\n    font-size: 1.8rem !important;\r\n    white-space: nowrap;\r\n    align-self: center;\r\n    line-height: var(--base-line-height);\r\n    padding: 0 1.2rem;\r\n    font-weight: 600;\r\n  }\r\n\r\n  @media (pointer: none), (pointer: coarse) {\r\n    .bottom .ctrl[data-name='playPause'],\r\n    .bottom .ctrl[data-name='playNext'],\r\n    .bottom .volume,\r\n    .bottom .ctrl[data-name='toggleFullscreen'] {\r\n      display: none;\r\n    }\r\n  }\r\n\r\n  ::-webkit-inner-spin-button {\r\n    opacity: 1;\r\n    margin-left: 0.4rem;\r\n    margin-right: -0.5rem;\r\n    filter: invert(0.84);\r\n    padding-top: 2rem;\r\n  }\r\n\r\n  /* Radio debloat for halfmoon */\r\n  .custom-radio {\r\n    display: flex;\r\n    flex-direction: column;\r\n  }\r\n  .custom-radio label {\r\n    position: relative;\r\n  }\r\n  .custom-radio input[type='radio']:hover + label:before {\r\n    background-color: var(--lm-radio-bg-color-hover);\r\n    border-color: var(--lm-radio-border-color-hover);\r\n  }\r\n  .custom-radio input[type='radio']:focus + label:before {\r\n    border-color: var(--lm-radio-border-color-focus);\r\n    -moz-box-shadow: var(--lm-radio-box-shadow-focus);\r\n    -webkit-box-shadow: var(--lm-radio-box-shadow-focus);\r\n    box-shadow: var(--lm-radio-box-shadow-focus);\r\n  }\r\n  .custom-radio input[type='radio']:checked + label:before {\r\n    background-color: var(--lm-radio-bg-color-checked);\r\n    border-color: var(--lm-radio-border-color-checked);\r\n  }\r\n  .custom-radio input[type='radio']:checked:focus + label:before {\r\n    border-color: var(--lm-radio-border-color-checked-focus);\r\n    -moz-box-shadow: var(--lm-radio-box-shadow-checked-focus);\r\n    -webkit-box-shadow: var(--lm-radio-box-shadow-checked-focus);\r\n    box-shadow: var(--lm-radio-box-shadow-checked-focus);\r\n  }\r\n  .dark-mode .custom-radio label:before {\r\n    background-color: var(--dm-radio-bg-color);\r\n    border-color: var(--dm-radio-border-color);\r\n  }\r\n  .dark-mode .custom-radio input[type='radio']:hover + label:before {\r\n    background-color: var(--dm-radio-bg-color-hover);\r\n    border-color: var(--dm-radio-border-color-hover);\r\n  }\r\n  .dark-mode .custom-radio input[type='radio']:focus + label:before {\r\n    border-color: var(--dm-radio-border-color-focus);\r\n    -moz-box-shadow: var(--dm-radio-box-shadow-focus);\r\n    -webkit-box-shadow: var(--dm-radio-box-shadow-focus);\r\n    box-shadow: var(--dm-radio-box-shadow-focus);\r\n  }\r\n  .dark-mode .custom-radio input[type='radio']:checked + label:before {\r\n    background-color: var(--dm-radio-bg-color-checked);\r\n    border-color: var(--dm-radio-border-color-checked);\r\n  }\r\n  .dark-mode .custom-radio input[type='radio']:checked:focus + label:before {\r\n    border-color: var(--dm-radio-border-color-checked-focus);\r\n    -moz-box-shadow: var(--dm-radio-box-shadow-checked-focus);\r\n    -webkit-box-shadow: var(--dm-radio-box-shadow-checked-focus);\r\n    box-shadow: var(--dm-radio-box-shadow-checked-focus);\r\n  }\r\n  .custom-radio label:after {\r\n    content: '';\r\n    position: absolute;\r\n    display: none;\r\n    top: var(--radio-checkmark-top);\r\n    left: var(--radio-checkmark-left);\r\n    width: var(--radio-checkmark-width-height);\r\n    height: var(--radio-checkmark-width-height);\r\n    background-color: var(--lm-radio-checkmark-color);\r\n    border-radius: var(--radio-checkmark-border-radius);\r\n  }\r\n  .custom-radio input[type='radio']:checked + label:after {\r\n    display: block;\r\n  }\r\n  .custom-radio input[type='radio']:disabled + label {\r\n    opacity: 0.6;\r\n    cursor: not-allowed;\r\n  }\r\n  .custom-radio input[type='radio']:disabled + label:before,\r\n  .custom-radio input[type='radio']:hover:disabled + label:before {\r\n    background-color: var(--lm-radio-bg-color);\r\n    border-color: var(--lm-radio-border-color);\r\n  }\r\n  .custom-radio input[type='radio']:disabled:checked + label:before,\r\n  .custom-radio input[type='radio']:hover:disabled:checked + label:before {\r\n    background-color: var(--lm-radio-bg-color-checked);\r\n    border-color: var(--lm-radio-border-color-checked);\r\n  }\r\n  .dark-mode .custom-radio input[type='radio']:disabled + label:before,\r\n  .dark-mode .custom-radio input[type='radio']:hover:disabled + label:before {\r\n    background-color: var(--dm-radio-bg-color);\r\n    border-color: var(--dm-radio-border-color);\r\n  }\r\n  .dark-mode .custom-radio input[type='radio']:disabled:checked + label:before,\r\n  .dark-mode .custom-radio input[type='radio']:hover:disabled:checked + label:before {\r\n    background-color: var(--dm-radio-bg-color-checked);\r\n    border-color: var(--dm-radio-border-color-checked);\r\n  }\r\n</style>\r\n","<script>\r\n  let deferredPrompt\r\n\r\n  window.addEventListener('beforeinstallprompt', e => {\r\n    e.preventDefault()\r\n    deferredPrompt = e\r\n  })\r\n  async function promptInstall () {\r\n    deferredPrompt.prompt()\r\n    const { outcome } = await deferredPrompt.userChoice\r\n    if (outcome === 'accepted') {\r\n      deferredPrompt = null\r\n    }\r\n  }\r\n  function dismiss () {\r\n    deferredPrompt = null\r\n  }\r\n</script>\r\n\r\n{#if deferredPrompt}\r\n  <div class=\"alert alert-success filled-dm show\" on:click={promptInstall}>\r\n    <h4 class=\"alert-heading\">Install</h4>\r\n    <button class=\"close\" type=\"button\" on:click={dismiss}><span>×</span></button>\r\n    Click here to install the app for more features!\r\n  </div>\r\n{/if}\r\n\r\n<style>\r\n  .alert {\r\n    display: block !important;\r\n    animation: fly-in 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);\r\n  }\r\n\r\n  @keyframes fly-in {\r\n    0% {\r\n      right: -50rem;\r\n    }\r\n    100% {\r\n      right: 0;\r\n    }\r\n  }\r\n</style>\r\n","<script context=\"module\">\r\n  import { get, set, createStore } from 'idb-keyval'\r\n\r\n  const supported = 'FileSystemFileHandle' in window\r\n\r\n  const asyncSome = async (arr, predicate) => {\r\n    for (const e of arr) {\r\n      if (await predicate(e)) return true\r\n    }\r\n    return false\r\n  }\r\n  const asyncFilter = async (arr, predicate) => {\r\n    const results = await Promise.all(arr.map(predicate))\r\n\r\n    return arr.filter((_v, index) => results[index])\r\n  }\r\n\r\n  let db = null\r\n  async function setHandles () {\r\n    handles = (await get('recents', db)) || []\r\n  }\r\n  export function initDb (appName) {\r\n    db = createStore(appName, 'recents')\r\n  }\r\n\r\n  let handles = []\r\n\r\n  // this is clunky, but dataTransfer doesn't persist across async calls.... https://stackoverflow.com/questions/55658851\r\n  export async function updateRecents (files) {\r\n    if (supported && db && files?.length) {\r\n      const promises = files\r\n        .map(file => (file instanceof FileSystemFileHandle ? file : file.getAsFileSystemHandle()))\r\n        .filter(file => file instanceof FileSystemFileHandle || file instanceof File)\r\n      if (!promises.length) return null\r\n      const newHandles = await Promise.all(promises)\r\n      await setHandles()\r\n      handles = await asyncFilter(handles, async handle => {\r\n        return !(await asyncSome(newHandles, recent => recent.isSameEntry(handle)))\r\n      })\r\n      handles.unshift(...newHandles)\r\n      handles.length = Math.min(handles.length, 15)\r\n      set('recents', handles, db)\r\n    }\r\n  }\r\n</script>\r\n\r\n<script>\r\n  export let files = null\r\n  let recents = []\r\n  setHandles().then(() => {\r\n    recents = handles\r\n  })\r\n  async function selectFile (handle) {\r\n    updateRecents([handle])\r\n    await handle.requestPermission({ mode: 'read' })\r\n    files = [await handle.getFile()]\r\n  }\r\n\r\n  export let handlePopup = () => {}\r\n</script>\r\n\r\n<div class=\"h-full my-0 bg-very-dark\">\r\n  <div class=\"container h-full p-20\">\r\n    <div class=\"p-20 d-flex flex-column h-full\">\r\n      <div class=\"font-weight-bold font-size-24 p-5\">Recent Files</div>\r\n      <hr class=\"w-full my-15\" />\r\n      <div class=\"overflow-y-auto\">\r\n        {#if supported}\r\n          {#each recents as recent}\r\n            <div class=\"p-5 pointer text-muted hover\" on:click={selectFile(recent)}>\r\n              <div class=\"ml-5\">{recent.name}</div>\r\n            </div>\r\n          {:else}\r\n            <div class=\"ml-5 p-5\">Your recent files will show up here!</div>\r\n          {/each}\r\n        {:else if window.chrome}\r\n          <div>\r\n            Your browser doesn't support recent files, but it could! Visit <code class=\"code\">chrome://flags</code> and enable <code class=\"code\">#file-system-access-api!</code>\r\n          </div>\r\n        {:else}\r\n          <div>Your browser doesn't support recent files.</div>\r\n        {/if}\r\n      </div>\r\n      <div class=\"py-20 pointer text-muted hover mt-auto\" on:click={handlePopup}>You can also drag-drop or paste files, or click here to select some!</div>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<style>\r\n  .pointer {\r\n    cursor: pointer;\r\n  }\r\n  .hover:hover {\r\n    color: #fff !important;\r\n  }\r\n</style>\r\n","<script>\r\n  import Player from './modules/Player.svelte'\r\n  import InstallPrompt from '../../shared/InstallPrompt.svelte'\r\n  import { filePopup, handleItems, getSearchFiles, getLaunchFiles } from '../../shared/inputHandler.js'\r\n  import { URLFile } from '../../shared/URLFile.js'\r\n  import RecentFiles, { initDb } from '../../shared/RecentFiles.svelte'\r\n\r\n  initDb('video-player')\r\n\r\n  let name = ''\r\n  let files = []\r\n\r\n  // mistakes have been made\r\n  if (navigator.serviceWorker?.controller?.scriptURL.endsWith('server-worker.js')) {\r\n    navigator.serviceWorker.ready.then(reg => {\r\n      reg.unregister().then(() => location.reload())\r\n    })\r\n  }\r\n\r\n  // loading files\r\n  async function handleInput({ dataTransfer, clipboardData }) {\r\n    const items = clipboardData?.items || dataTransfer?.items\r\n    if (items) {\r\n      handleFiles(await handleItems(items, ['video', 'subtitle']))\r\n    }\r\n  }\r\n\r\n  if ('launchQueue' in window) {\r\n    getLaunchFiles().then(handleFiles)\r\n  }\r\n  async function handlePopup() {\r\n    if (!files.length) {\r\n      handleFiles(await filePopup(['video', 'subtitle']))\r\n    }\r\n  }\r\n  async function handleFiles(newfiles) {\r\n    if (newfiles?.length) {\r\n      files = files.concat(\r\n        await Promise.all(\r\n          newfiles.map(async file => {\r\n            if (file instanceof File) return file\r\n            const urlfile = new URLFile(file)\r\n            if (!((await urlfile.ready) instanceof Error)) {\r\n              return urlfile\r\n            }\r\n            return file\r\n          })\r\n        )\r\n      )\r\n    }\r\n  }\r\n  handleFiles(getSearchFiles(['video', 'subtitle']))\r\n</script>\r\n\r\n<div class=\"sticky-alerts d-flex flex-column-reverse\">\r\n  <InstallPrompt />\r\n</div>\r\n<div class=\"page-wrapper\">\r\n  {#if !files.length}\r\n    <RecentFiles bind:files {handlePopup} />\r\n  {:else}\r\n    <Player bind:files bind:name />\r\n  {/if}\r\n</div>\r\n\r\n<svelte:head>\r\n  <title>{name || 'Video Player'}</title>\r\n</svelte:head>\r\n\r\n<svelte:window on:drop|preventDefault={handleInput} on:dragover|preventDefault on:paste|preventDefault={handleInput} />\r\n\r\n<style>\r\n  * {\r\n    user-select: none;\r\n  }\r\n  .sticky-alerts {\r\n    --sticky-alerts-top: auto;\r\n    bottom: 1rem;\r\n  }\r\n</style>\r\n"],"names":[],"sourceRoot":""}