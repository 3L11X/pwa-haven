{"version":3,"file":"build/bundle.css","mappings":"AAuHE,+CAAkB,aACF,CACd,gBAAiB,CACjB,YAAa,CACb,cAAe,CACf,UAAW,CACX,6BAA8B,CAC9B,mBAAoB,CACpB,WAAY,CACZ,UAAW,CACZ,qDAEuB,6BACQ,CAC/B,4DAE8B,sBACN,CACxB,mDAEuB,UACX,CACX,YAAa,CACb,kBAAmB,CACnB,mBAAoB,CACpB,cAAe,CACf,sCAAuC,CACvC,wBAAyB,CACzB,+BAAgC,CACjC,qDACoC,8BACJ,CAChC,yDAC6B,oBACP,CACtB,qDACuB,oBACD,CACtB,qDACuB,sBACC,CACxB,qDACuB,sBACC,CACxB,qDACuB,oBACD,CACtB,sDACwB,oBACF,CACtB,sDACwB,qBACD,CACvB,sDACwB,uBACC,CACzB,sDACwB,qBACD;AAhL1B,6uQAA6uQ,C;ACkF3uQ,8BAAiB,gBACE,CACjB,cAAe,CACf,YAAa,CACd,oBACM,cACU,CAChB,0BACY,gCACsB,CAClC,0CAC4B,SACjB,CACV,kBAAmB,CACnB,oBAAqB,CACrB,mBAAoB,CACpB,gBAAiB;AAlGrB,6iNAA6iN,C;ACoG3iN,+BAAiB,gBACE,CACjB,cAAe,CACf,YAAa,CACd,qBACM,cACU,CAChB,2BACY,gCACsB,CAClC,iCAC2B,uBACF;AAhH5B,6yKAA6yK,C;AC0D3yK,+BAAiB,gBACE,CACjB,cAAe,CACf,YAAa,CACd,qBACM,cACU,CAChB,2BACY,gCACsB,CAClC,iCAC2B,uBACF;AAtE5B,igHAAigH,C;AC2D//G,kDAAqB,uBACK,CACxB,sBAAuB,CACvB,QAAS,CACT,cAAe,CACf,UAAW,CACZ,wDAE0B,YACZ,CACd,iFAEmD,UACvC,CACZ,oEAEsC,UAC1B,CACX,WAAY,CACb,wEAE0C,QAChC,CACT,OAAQ,CACR,iBAAkB,CAClB,kBAAmB,CACnB,uBAAwB,CACxB,eAAgB,CAChB,wBAAyB,CAC1B,oEACsC,QAC5B,CACT,OAAQ,CACR,iBAAkB,CAClB,kBAAmB,CACnB,uBAAwB,CACxB,eAAgB,CAChB,wBAAyB,CACzB,WAAY,CACb,8EAEgD,WACnC,CACZ,UAAW,CACX,eAAgB,CACjB,0EAE4C,WAC/B,CACZ,UAAW,CACX,eAAgB,CACjB,oEAEsC,8FAC0D,CAChG,iFACmD,8FAC6C,CAChG,oCACM,cACU,CAChB,0CACY,gCACsB,CAClC,2CAEe,mBACM,CACpB,SAAU,CACV,KAAM,CACN,gCAAiC,CACjC,iBAAkB,CAClB,gDAAiD,CACjD,kBAAmB,CACnB,eAAgB,CAChB,WAAY,CACZ,4BAA6B,CAC9B,iDAEqB,SACV,CACX,oCACM;EAEP,CAAC,qCACO,oBACe,CACtB,kCACI,aACW,CACd,yBAA0B,CAC1B,kBAAmB,CACnB,iBAAkB,CAClB,mCAAoC,CACpC,iBAAkB,CAClB,eAAgB,CACjB,2CACa,uBACY;AA5J5B,6ySAA6yS,C;AC0D3yS,qCAAQ,oBACe,CACrB,0BAA2B,CAC5B,4CACc,iBACK,CAClB,KAAM,CACN,OAAQ,CACR,cAAe,CACf,aAAc,CACd,kCAAmC,CACnC,0CAA2C,CAC3C,sCAAuC,CACvC,4BAA6B,CAC7B,wBAAyB;AAzE7B,qsIAAqsI,C;ACqmBnsI,kCAAO,gBACY,CACjB,gBAAiB,CACjB,YAAa,CACb,sBAAuB,CACvB,kBAAmB,CACnB,YAAa,CACb,sBAAuB,CACvB,kBAAmB,CACnB,WAAY,CACb,iDACqB,2BACQ,CAC5B,4BAA6B,CAC9B,wCACY,sBACY,CACxB,6FAEoB,uBACK,CACzB,8CACkB,4BACY,CAC9B,mCACO,oBACe,CACrB,0BAA2B,CAC5B,0CACc,iBACK,CAClB,KAAM,CACN,OAAQ,CACR,cAAe,CACf,aAAc,CACd,kCAAmC,CACnC,0CAA2C,CAC3C,sCAAuC,CACvC,4BAA6B,CAC7B,wBAAyB,CAC1B,kCAEM,+BAC2B,CACjC,oCACQ,gBACU,CACjB,gDAAiD,CACjD,wCAAyC,CACzC,iBAAkB,CAClB,eAAgB,CACjB,+CACmB,oBACG,CACrB,yBAA0B,CAC3B,uCAEkC,oBACZ,CACrB,qBAAsB,CAEvB,4CAEgB,gBACE,CACjB,cAAe,CACf,YAAa,CACd,sCAEU,WACG,CACb,6IAIkB,SACP,CACX,uCAEW;EAEZ,CAAC,sEAE0C,0BACd,CAC3B,yBAA0B,CAC1B,iBAAkB,CAClB,UAAW,CACX,WAAY,CACZ,+CAAkC,CAClC,SAAU,CACV,4BAA6B,CAC7B,gCAAiC,CAClC,sCACU,6BACqB,CAC/B,iFAEqD,oBAC/B,CACtB,8BAEgB,GACX,sBACqB,CACxB,KAEK,wBACqB,CAC1B,CACF,0CAEc,cACE,CACf,WAAY,CACZ,SAAU,CACV,YAAa,CACd,wCACY,0BACgB,CAC5B,yCAE0C,0CAC1B,YACA,CACd,kDACsB,uBACG,CACzB,CACF,gDACoB,+BACa,CAChC,4BAA6B,CAC7B,UAAW,CACX,WAAY,CACb,sDAC0B,YACZ,CACb,gBAAiB,CACjB,aAAc,CACf,8DACkC,uBACT,CACzB,6EACiD,kBAC7B,CACpB,sDAC0B,oBACJ,CACtB,iEACqC,iBAClB,CACnB,uLAKmB,gCACe,CAClC,oCAEQ,gBACU,CACjB,2IAA4I,CAC5I,4BAA6B,CAC9B,iCACK,8IAC2I,CAC/I,4BAA6B,CAC9B,kCAEM,cACU,CAChB,gDAEoB,uBACK,CACxB,sBAAuB,CACvB,QAAS,CACT,cAAe,CACf,UAAW,CACZ,sDAE0B,YACZ,CACd,+EAEmD,UACvC,CACZ,kEAEsC,UAC1B,CACX,WAAY,CACb,sEAE0C,QAChC,CACT,OAAQ,CACR,iBAAkB,CAClB,kBAAmB,CACnB,uBAAwB,CACxB,eAAgB,CAChB,wBAAyB,CAC1B,kEACsC,QAC5B,CACT,OAAQ,CACR,iBAAkB,CAClB,kBAAmB,CACnB,uBAAwB,CACxB,eAAgB,CAChB,wBAAyB,CACzB,WAAY,CACb,4EAEgD,WACnC,CACZ,UAAW,CACX,eAAgB,CACjB,wEAE4C,WAC/B,CACZ,UAAW,CACX,eAAgB,CACjB,kEAEsC,8FAC0D,CAChG,+EACmD,8FAC6C,CAChG,sEAC0C,SAC/B,CACV,oBAAqB,CACrB,qBAAsB,CACvB,gEAEoC,OAC3B,CACR,0BAA2B,CAC3B,WAAY,CACb,wCAEY,aACG,CACd,yBAA0B,CAC1B,kBAAmB,CACnB,iBAAkB,CAClB,mCAAoC,CACpC,iBAAkB,CAClB,eAAgB,CACjB,yCAE0C,qPAII,YAC9B,CACd;AA12BL,q78CAAq78C,C;AC0Bn78C,sBAAQ,wBACmB,CACzB,qEAAuD,CACxD,iCAEkB,GACb,YACW,CACd,KACK,OACI,CACT;AAtCL,y9DAAy9D,C;ACwFv9D,wBAAU,cACO,CAChB,4BACa,qBACU;AA5F1B,6tJAA6tJ,C;ACuE3tJ,gBAAG,gBACgB,CAClB,8BACe,wBACW,CACzB,WAAY;AA5EhB,i8GAAi8G,C","sources":["webpack:///../node_modules/svelte-keybinds/Keybinds.svelte","webpack:///./src/modules/player/TrackControls.svelte","webpack:///./src/modules/player/CastControls.svelte","webpack:///./src/modules/player/PopoutControls.svelte","webpack:///./src/modules/player/SeekControls.svelte","webpack:///./src/modules/player/Stats.svelte","webpack:///./src/modules/Player.svelte","webpack:///../shared/InstallPrompt.svelte","webpack:///../shared/RecentFiles.svelte","webpack:///./src/App.svelte"],"sourcesContent":["<script context='module'>\r\n  import { writable } from 'svelte/store'\r\n  import { keys, layout } from './maps.js'\r\n\r\n  let kbn = null\r\n\r\n  export const binds = writable(null)\r\n  binds.subscribe((obj) => {\r\n    kbn = obj ?? {}\r\n  })\r\n\r\n  let cnd = null\r\n\r\n  export const condition = writable(() => true)\r\n  condition.subscribe((fn) => {\r\n    if (typeof fn !== 'function') throw new Error('Condition must be a function')\r\n    cnd = fn\r\n  })\r\n\r\n  window.addEventListener('keydown', runBind)\r\n\r\n  async function runBind (e) {\r\n    if (await cnd(e)) kbn[layout[e.code] || e.code]?.fn?.(e)\r\n  }\r\n\r\n  export function loadWithDefaults (defaults) {\r\n    const def = toIDmap(defaults)\r\n    const saved = JSON.parse(localStorage.getItem('thaunknown/svelte-keybinds'))\r\n    for (const id in saved) {\r\n      saved[id].fn = def[id]?.fn\r\n    }\r\n    binds.set(toKeyMap({ ...def, ...saved }))\r\n  }\r\n\r\n  function toIDmap (target = {}) {\r\n    const obj = {}\r\n    for (const code in target) {\r\n      const bind = target[code]\r\n      obj[bind.id] = { ...bind, code }\r\n    }\r\n    return obj\r\n  }\r\n\r\n  function toKeyMap (target = {}) {\r\n    const obj = {}\r\n    for (const code in target) {\r\n      const bind = target[code]\r\n      obj[bind.code] = { ...bind, code }\r\n    }\r\n    return obj\r\n  }\r\n\r\n  function save () {\r\n    localStorage.setItem('thaunknown/svelte-keybinds', JSON.stringify(toIDmap(kbn)))\r\n  }\r\n</script>\r\n\r\n<script>\r\n  export let autosave = false\r\n\r\n  export let clickable = false\r\n\r\n  const kbnref = kbn\r\n  let dragged = null\r\n  function draggable (node, code) {\r\n    let drag = false\r\n    node.addEventListener('dragstart', ({ target }) => {\r\n      dragged = target\r\n      target.classList.add('transparent')\r\n      drag = true\r\n    })\r\n    node.addEventListener('dragend', ({ target }) => {\r\n      target.classList.remove('transparent')\r\n      drag = false\r\n    })\r\n    node.addEventListener('dragover', (e) => {\r\n      e.dataTransfer.dropEffect = 'move'\r\n      e.preventDefault()\r\n      if (!drag) e.target.classList.add('transparent')\r\n    })\r\n    node.addEventListener('dragleave', ({ target }) => {\r\n      if (!drag) target.classList.remove('transparent')\r\n    })\r\n    node.addEventListener('drop', ({ target }) => {\r\n      target.style.opacity = null\r\n      const targetcode = dragged.dataset.code\r\n      if (kbnref[code]) {\r\n        const temp = kbnref[targetcode]\r\n        kbnref[targetcode] = kbnref[code]\r\n        kbnref[code] = temp\r\n      } else {\r\n        kbnref[code] = kbnref[targetcode]\r\n        delete kbnref[targetcode]\r\n      }\r\n      binds.set(kbnref)\r\n      if (autosave === true) {\r\n        save()\r\n      }\r\n    })\r\n  }\r\n</script>\r\n\r\n<div class='svelte-keybinds'>\r\n  {#each Object.values(keys) as key}\r\n    {@const { size, dark, name } = key}\r\n    <div\r\n      class:dark\r\n      draggable={!!kbnref[name]}\r\n      data-code={name}\r\n      class='w-{size || 50}'\r\n      {...$$restProps}\r\n      use:draggable={name}\r\n      on:click={(e) => clickable && runBind(Object.assign(e, { code: name }))}>\r\n      <slot prop={kbnref[name]} />\r\n    </div>\r\n  {/each}\r\n</div>\r\n\r\n<style>\r\n  .svelte-keybinds {\r\n    flex-shrink: 0;\r\n    user-select: none;\r\n    display: flex;\r\n    flex-wrap: wrap;\r\n    width: 82em;\r\n    background: rgba(0, 0, 0, 0.8);\r\n    border-radius: 0.4em;\r\n    padding: 1em;\r\n    color: #eee;\r\n  }\r\n\r\n  .svelte-keybinds .dark {\r\n    background: #191c20 !important;\r\n  }\r\n\r\n  .svelte-keybinds .transparent {\r\n    opacity: 0.2 !important;\r\n  }\r\n\r\n  .svelte-keybinds > div {\r\n    height: 4em;\r\n    margin: 0.5em;\r\n    background: #25282c;\r\n    border-radius: 0.4em;\r\n    cursor: pointer;\r\n    transition-property: opacity, transform;\r\n    transition-duration: 0.2s;\r\n    transition-timing-function: ease;\r\n  }\r\n  .svelte-keybinds > div > :global(*) {\r\n    pointer-events: none !important;\r\n  }\r\n  .svelte-keybinds > div:hover {\r\n    transform: scale(0.9);\r\n  }\r\n  .svelte-keybinds .w-50 {\r\n    width: 4em !important;\r\n  }\r\n  .svelte-keybinds .w-75 {\r\n    width: 6.5em !important;\r\n  }\r\n  .svelte-keybinds .w-85 {\r\n    width: 7.5em !important;\r\n  }\r\n  .svelte-keybinds .w-90 {\r\n    width: 8em !important;\r\n  }\r\n  .svelte-keybinds .w-100 {\r\n    width: 9em !important;\r\n  }\r\n  .svelte-keybinds .w-110 {\r\n    width: 10em !important;\r\n  }\r\n  .svelte-keybinds .w-115 {\r\n    width: 10.5em !important;\r\n  }\r\n  .svelte-keybinds .w-300 {\r\n    width: 29em !important;\r\n  }\r\n</style>\r\n","<script>\r\n  import { toggleDropdown } from './common.js'\r\n  export let subHeaders = null\r\n  export let video = null\r\n  let subDelay = 0\r\n  export let subs = null\r\n\r\n  $: updateDelay(subDelay)\r\n  function updateDelay (delay) {\r\n    if (subs?.renderer) subs.renderer.timeOffset = delay\r\n  }\r\n  function selectAudio (id) {\r\n    if (id !== undefined) {\r\n      for (const track of video.audioTracks) {\r\n        track.enabled = track.id === id\r\n      }\r\n      video.currentTime -= 0.1\r\n    }\r\n  }\r\n  function selectVideo (id) {\r\n    if (id !== undefined) {\r\n      for (const track of video.videoTracks) {\r\n        track.selected = track.id === id\r\n      }\r\n    }\r\n  }\r\n\r\n</script>\r\n<!-- svelte-ignore missing-declaration -->\r\n{#if 'audioTracks' in HTMLVideoElement.prototype && video?.audioTracks?.length > 1}\r\n  <div class='dropdown dropup with-arrow' on:click={toggleDropdown}>\r\n    <span class='material-icons ctrl' title='Audio Tracks'>\r\n      queue_music\r\n    </span>\r\n    <div class='dropdown-menu dropdown-menu-left ctrl custom-radio p-10 pb-5 text-capitalize'>\r\n      {#each video.audioTracks as track}\r\n        <input name='audio-radio-set' type='radio' id='audio-{track.id}-radio' value={track.id} checked={track.enabled} />\r\n        <label for='audio-{track.id}-radio' on:click|stopPropagation={() => selectAudio(track.id)} class='text-truncate pb-5'>\r\n          {(track.language || (!Object.values(video.audioTracks).some(track => track.language === 'eng' || track.language === 'en') ? 'eng' : track.label)) +\r\n            (track.label ? ' - ' + track.label : '')}</label>\r\n      {/each}\r\n    </div>\r\n  </div>\r\n{/if}\r\n<!-- svelte-ignore missing-declaration -->\r\n{#if 'videoTracks' in HTMLVideoElement.prototype && video?.videoTracks?.length > 1}\r\n  <div class='dropdown dropup with-arrow' on:click={toggleDropdown}>\r\n    <span class='material-icons ctrl' title='Video Tracks'>\r\n      playlist_play\r\n    </span>\r\n    <div class='dropdown-menu dropdown-menu-left ctrl custom-radio p-10 pb-5 text-capitalize'>\r\n      {#each video.videoTracks as track}\r\n        <input name='video-radio-set' type='radio' id='video-{track.id}-radio' value={track.id} checked={track.selected} />\r\n        <label for='video-{track.id}-radio' on:click|stopPropagation={() => selectVideo(track.id)} class='text-truncate pb-5'>\r\n          {(track.language || (!Object.values(video.videoTracks).some(track => track.language === 'eng' || track.language === 'en') ? 'eng' : track.label)) +\r\n            (track.label ? ' - ' + track.label : '')}</label>\r\n      {/each}\r\n    </div>\r\n  </div>\r\n{/if}\r\n{#if subHeaders?.length}\r\n  <div class='dropdown dropup with-arrow' on:click={toggleDropdown}>\r\n    <span class='material-icons ctrl' title='Subtitles [C]'>\r\n      subtitles\r\n    </span>\r\n    <div class='dropdown-menu dropdown-menu-right ctrl custom-radio p-10 pb-5 text-capitalize w-200'>\r\n      <input name='subtitle-radio-set' type='radio' id='subtitle-off-radio' value='off' checked={subHeaders && subs?.current === -1} />\r\n      <label for='subtitle-off-radio' on:click|stopPropagation={() => subs.selectCaptions(-1)} class='text-truncate pb-5'> OFF </label>\r\n      {#each subHeaders as track}\r\n        {#if track}\r\n          <input name='subtitle-radio-set' type='radio' id='subtitle-{track.number}-radio' value={track.numer} checked={track.number === subs.current} />\r\n          <label for='subtitle-{track.nubmer}-radio' on:click={() => subs.selectCaptions(track.number)} class='text-truncate pb-5'>\r\n            {(track.language || (!Object.values(subs.headers).some(header => header.language === 'eng' || header.language === 'en') ? 'eng' : track.type)) +\r\n              (track.name ? ' - ' + track.name : '')}\r\n          </label>\r\n        {/if}\r\n      {/each}\r\n      <input type='number' step='0.1' bind:value={subDelay} class='form-control text-right form-control-sm' />\r\n    </div>\r\n  </div>\r\n{/if}\r\n\r\n<style>\r\n  .material-icons {\r\n    font-size: 2.6rem;\r\n    padding: 1.5rem;\r\n    display: flex;\r\n  }\r\n  .ctrl {\r\n    cursor: pointer;\r\n  }\r\n  .ctrl:hover {\r\n    filter: drop-shadow(0 0 8px #000);\r\n  }\r\n  ::-webkit-inner-spin-button {\r\n    opacity: 1;\r\n    margin-left: 0.4rem;\r\n    margin-right: -0.5rem;\r\n    filter: invert(0.84);\r\n    padding-top: 2rem;\r\n  }\r\n</style>\r\n","<script>\r\n  import Peer from '../../../../shared/Peer.js'\r\n  import { getBurnIn } from './common.js'\r\n\r\n  export let video = null\r\n  export let subs = null\r\n  export let paused = false\r\n  export let container\r\n  let canCast = false\r\n\r\n  let presentationConnection = null\r\n  let presentationRequest = null\r\n\r\n  if ('PresentationRequest' in window) {\r\n    const handleAvailability = aval => {\r\n      canCast = !!aval\r\n    }\r\n    presentationRequest = new PresentationRequest(['build/cast.html'])\r\n    presentationRequest.addEventListener('connectionavailable', e => initCast(e))\r\n    navigator.presentation.defaultRequest = presentationRequest\r\n    presentationRequest.getAvailability().then(aval => {\r\n      aval.onchange = e => handleAvailability(e.target.value)\r\n      handleAvailability(aval.value)\r\n    })\r\n  }\r\n\r\n  export function toggleCast () {\r\n    if (video.readyState) {\r\n      if (presentationConnection) {\r\n        presentationConnection?.terminate()\r\n      } else {\r\n        presentationRequest.start()\r\n      }\r\n    }\r\n  }\r\n  function initCast (event) {\r\n    // these quality settings are likely to make cast overheat, oh noes!\r\n    let peer = new Peer({\r\n      polite: true,\r\n      quality: {\r\n        audio: {\r\n          stereo: 1,\r\n          'sprop-stereo': 1,\r\n          maxaveragebitrate: 510000,\r\n          maxplaybackrate: 510000,\r\n          cbr: 0,\r\n          useinbandfec: 1,\r\n          usedtx: 1,\r\n          maxptime: 20,\r\n          minptime: 10\r\n        },\r\n        video: {\r\n          bitrate: 2000000,\r\n          codecs: ['H264', 'VP9', 'VP8']\r\n        }\r\n      }\r\n    })\r\n\r\n    presentationConnection = event.connection\r\n    presentationConnection.addEventListener('terminate', () => {\r\n      presentationConnection = null\r\n      peer = null\r\n    })\r\n\r\n    peer.signalingPort.onmessage = ({ data }) => {\r\n      presentationConnection.send(data)\r\n    }\r\n\r\n    presentationConnection.addEventListener('message', ({ data }) => {\r\n      peer.signalingPort.postMessage(data)\r\n    })\r\n\r\n    peer.dc.onopen = () => {\r\n      if (peer && presentationConnection) {\r\n        const tracks = []\r\n        const videostream = video.captureStream()\r\n        if (subs?.renderer) {\r\n          // TODO: check if cast supports codecs\r\n          const { stream, destroy, canvas } = getBurnIn(video, subs)\r\n          container.append(canvas)\r\n          tracks.push(stream.getVideoTracks()[0], videostream.getAudioTracks()[0])\r\n          presentationConnection.addEventListener('terminate', destroy)\r\n        } else {\r\n          tracks.push(videostream.getVideoTracks()[0], videostream.getAudioTracks()[0])\r\n        }\r\n        for (const track of tracks) {\r\n          peer.pc.addTrack(track, videostream)\r\n        }\r\n        paused = false // video pauses for some reason\r\n      }\r\n    }\r\n  }\r\n</script>\r\n\r\n{#if 'PresentationRequest' in window && canCast && video.readyState}\r\n  <span class='material-icons ctrl' title='Cast Video [D]' data-name='toggleCast' on:click={toggleCast}>\r\n    {presentationConnection ? 'cast_connected' : 'cast'}\r\n  </span>\r\n{/if}\r\n\r\n<style>\r\n  .material-icons {\r\n    font-size: 2.6rem;\r\n    padding: 1.5rem;\r\n    display: flex;\r\n  }\r\n  .ctrl {\r\n    cursor: pointer;\r\n  }\r\n  .ctrl:hover {\r\n    filter: drop-shadow(0 0 8px #000);\r\n  }\r\n  :global(:fullscreen) .ctrl {\r\n    display: none !important;\r\n  }\r\n</style>\r\n","<script>\r\n  import { getBurnIn } from './common.js'\r\n\r\n  export let video\r\n  export let subs\r\n  export let pip = false\r\n  export let container\r\n\r\n  export function togglePopout () {\r\n    if (video.readyState) {\r\n      if (!subs?.renderer) {\r\n        if (video !== document.pictureInPictureElement) {\r\n          video.requestPictureInPicture()\r\n          pip = true\r\n        } else {\r\n          document.exitPictureInPicture()\r\n          pip = false\r\n        }\r\n      } else {\r\n        if (document.pictureInPictureElement && !document.pictureInPictureElement.id) {\r\n          // only exit if pip is the custom one, else overwrite existing pip with custom\r\n          document.exitPictureInPicture()\r\n          pip = false\r\n        } else {\r\n          const canvasVideo = document.createElement('video')\r\n          const { stream, destroy, canvas } = getBurnIn(video, subs)\r\n          container.append(canvas)\r\n          const cleanup = () => {\r\n            pip = false\r\n            destroy()\r\n            canvasVideo.remove()\r\n          }\r\n          pip = true\r\n          canvasVideo.srcObject = stream\r\n          canvasVideo.onloadedmetadata = () => {\r\n            canvasVideo.play()\r\n            if (pip) {\r\n              canvasVideo.requestPictureInPicture().catch(e => {\r\n                cleanup()\r\n                console.warn('Failed To Burn In Subtitles ' + e)\r\n              })\r\n            } else {\r\n              cleanup()\r\n            }\r\n          }\r\n          canvasVideo.onleavepictureinpicture = cleanup\r\n        }\r\n      }\r\n    }\r\n  }\r\n</script>\r\n\r\n{#if 'pictureInPictureEnabled' in document}\r\n  <span class='material-icons ctrl' title='Popout Window [P]' on:click={togglePopout}>\r\n    {pip ? 'featured_video' : 'picture_in_picture'}\r\n  </span>\r\n{/if}\r\n\r\n<style>\r\n  .material-icons {\r\n    font-size: 2.6rem;\r\n    padding: 1.5rem;\r\n    display: flex;\r\n  }\r\n  .ctrl {\r\n    cursor: pointer;\r\n  }\r\n  .ctrl:hover {\r\n    filter: drop-shadow(0 0 8px #000);\r\n  }\r\n  :global(:fullscreen) .ctrl {\r\n    display: none !important;\r\n  }\r\n</style>\r\n","<script>\r\n  import { toTS } from '../../../../shared/util.js'\r\n  export let currentTime = 0\r\n  export let safeduration = 0\r\n  export let targetTime = 0\r\n  export let thumbnailData = null\r\n  export let paused = false\r\n  $: progress = currentTime / safeduration\r\n\r\n  let thumbnail = ' '\r\n  let hover = null\r\n  let hoverTime = 0\r\n  let hoverOffset = 0\r\n  function handleHover ({ offsetX, target }) {\r\n    hoverOffset = offsetX / target.clientWidth\r\n    hoverTime = safeduration * hoverOffset\r\n    hover.style.setProperty('left', hoverOffset * 100 + '%')\r\n    thumbnail = thumbnailData.thumbnails[Math.floor(hoverTime / thumbnailData.interval)] || ' '\r\n  }\r\n  let wasPaused = false\r\n  function handleMouseDown ({ target }) {\r\n    wasPaused = paused\r\n    paused = true\r\n    targetTime = target.value * safeduration\r\n  }\r\n  function handleMouseUp () {\r\n    paused = wasPaused\r\n    currentTime = targetTime\r\n  }\r\n  function handleProgress ({ target }) {\r\n    targetTime = target.value * safeduration\r\n  }\r\n</script>\r\n\r\n<div class='w-full d-flex align-items-center h-20 mb--5'>\r\n  <div class='w-full h-full position-relative d-flex align-items-center'>\r\n    <input\r\n      class='ctrl w-full h-full prog'\r\n      type='range'\r\n      min='0'\r\n      max='1'\r\n      step='any'\r\n      data-name='setProgress'\r\n      bind:value={progress}\r\n      on:mousedown={handleMouseDown}\r\n      on:mouseup={handleMouseUp}\r\n      on:mousemove={handleHover}\r\n      on:input={handleProgress}\r\n      on:touchstart={handleMouseDown}\r\n      on:touchend={handleMouseUp}\r\n      on:keydown|preventDefault\r\n      style='--value: {progress * 100}%' />\r\n    <div class='hover position-absolute d-flex flex-column align-items-center' bind:this={hover}>\r\n      <img alt='thumbnail' class='w-full mb-5 shadow-lg' src={thumbnail} />\r\n      <div class='ts'>{toTS(hoverTime)}</div>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<style>\r\n  input[type='range'] {\r\n    -webkit-appearance: none;\r\n    background: transparent;\r\n    margin: 0;\r\n    cursor: pointer;\r\n    height: 8px;\r\n  }\r\n\r\n  input[type='range']:focus {\r\n    outline: none;\r\n  }\r\n\r\n  input[type='range']::-webkit-slider-runnable-track {\r\n    height: 3px;\r\n  }\r\n\r\n  input[type='range']::-moz-range-track {\r\n    height: 3px;\r\n    border: none;\r\n  }\r\n\r\n  input[type='range']::-webkit-slider-thumb {\r\n    height: 0;\r\n    width: 0;\r\n    border-radius: 50%;\r\n    background: #ff3c00;\r\n    -webkit-appearance: none;\r\n    appearance: none;\r\n    transition: all 0.1s ease;\r\n  }\r\n  input[type='range']::-moz-range-thumb {\r\n    height: 0;\r\n    width: 0;\r\n    border-radius: 50%;\r\n    background: #ff3c00;\r\n    -webkit-appearance: none;\r\n    appearance: none;\r\n    transition: all 0.1s ease;\r\n    border: none;\r\n  }\r\n\r\n  input[type='range']:hover::-webkit-slider-thumb {\r\n    height: 12px;\r\n    width: 12px;\r\n    margin-top: -4px;\r\n  }\r\n\r\n  input[type='range']:hover::-moz-range-thumb {\r\n    height: 12px;\r\n    width: 12px;\r\n    margin-top: -4px;\r\n  }\r\n\r\n  input[type='range']::-moz-range-track {\r\n    background: linear-gradient(90deg, #ff3c00 var(--value), rgba(255, 255, 255, 0.2) var(--value));\r\n  }\r\n  input[type='range']::-webkit-slider-runnable-track {\r\n    background: linear-gradient(90deg, #ff3c00 var(--value), rgba(255, 255, 255, 0.2) var(--value));\r\n  }\r\n  .ctrl {\r\n    cursor: pointer;\r\n  }\r\n  .ctrl:hover {\r\n    filter: drop-shadow(0 0 8px #000);\r\n  }\r\n\r\n  input ~ .hover {\r\n    pointer-events: none;\r\n    opacity: 0;\r\n    top: 0;\r\n    transform: translate(-50%, -100%);\r\n    position: absolute;\r\n    font-family: Roboto, Arial, Helvetica, sans-serif;\r\n    white-space: nowrap;\r\n    font-weight: 600;\r\n    width: 200px;\r\n    transition: 0.2s opacity ease;\r\n  }\r\n\r\n  input:hover ~ .hover {\r\n    opacity: 1;\r\n  }\r\n  .h-20 {\r\n    height: 2rem\r\n  }\r\n  .mb--5 {\r\n    margin-bottom: -.5rem;\r\n  }\r\n  .ts {\r\n    color: #ececec;\r\n    font-size: 2rem !important;\r\n    white-space: nowrap;\r\n    align-self: center;\r\n    line-height: var(--base-line-height);\r\n    padding: 0 1.56rem;\r\n    font-weight: 600;\r\n  }\r\n  img[src=' '] {\r\n    display: none !important;\r\n  }\r\n</style>\r\n","<script>\r\n  export let video\r\n  let stats = null\r\n  let requestCallback = null\r\n  export function toggleStats () {\r\n    if ('requestVideoFrameCallback' in HTMLVideoElement.prototype) {\r\n      if (requestCallback) {\r\n        stats = null\r\n        video.cancelVideoFrameCallback(requestCallback)\r\n        requestCallback = null\r\n      } else {\r\n        requestCallback = video.requestVideoFrameCallback((a, b) => {\r\n          stats = {}\r\n          handleStats(a, b, b)\r\n        })\r\n      }\r\n    }\r\n  }\r\n  async function handleStats (now, metadata, lastmeta) {\r\n    if (stats) {\r\n      const msbf = (metadata.mediaTime - lastmeta.mediaTime) / (metadata.presentedFrames - lastmeta.presentedFrames)\r\n      const fps = (1 / msbf).toFixed(3)\r\n      stats = {\r\n        fps,\r\n        presented: metadata.presentedFrames,\r\n        dropped: video.getVideoPlaybackQuality()?.droppedVideoFrames,\r\n        processing: metadata.processingDuration + ' ms',\r\n        viewport: video.clientWidth + 'x' + video.clientHeight,\r\n        resolution: video.videoWidth + 'x' + video.videoHeight,\r\n        buffer: getBufferHealth(metadata.mediaTime) + ' s',\r\n        speed: video.playbackRate || 1\r\n      }\r\n      setTimeout(() => video.requestVideoFrameCallback((n, m) => handleStats(n, m, metadata)), 200)\r\n    }\r\n  }\r\n  function getBufferHealth (time) {\r\n    for (let index = video.buffered.length; index--;) {\r\n      if (time < video.buffered.end(index) && time > video.buffered.start(index)) {\r\n        return parseInt(video.buffered.end(index) - time)\r\n      }\r\n    }\r\n    return 0\r\n  }\r\n</script>\r\n\r\n{#if stats}\r\n  <div class='position-absolute top-0 bg-tp p-10 m-15 text-monospace rounded z-50'>\r\n    <button class='close' type='button' on:click={toggleStats}><span>×</span></button>\r\n    FPS: {stats.fps}<br />\r\n    Presented frames: {stats.presented}<br />\r\n    Dropped frames: {stats.dropped}<br />\r\n    Frame time: {stats.processing}<br />\r\n    Viewport: {stats.viewport}<br />\r\n    Resolution: {stats.resolution}<br />\r\n    Buffer health: {stats.buffer}<br />\r\n    Playback speed: x{stats.speed?.toFixed(1)}\r\n  </div>\r\n{/if}\r\n\r\n<style>\r\n  .bg-tp {\r\n    background: #000000bb;\r\n    backdrop-filter: blur(10px);\r\n  }\r\n  .bg-tp .close {\r\n    position: absolute;\r\n    top: 0;\r\n    right: 0;\r\n    cursor: pointer;\r\n    color: inherit;\r\n    padding: var(--alert-close-padding);\r\n    line-height: var(--alert-close-line-height);\r\n    font-size: var(--alert-close-font-size);\r\n    background-color: transparent;\r\n    border-color: transparent;\r\n  }\r\n</style>\r\n","<script>\r\n  import { tick } from 'svelte'\r\n  import { setFile, speed } from './server.js'\r\n  import './File.js'\r\n  import Subtitles from './subtitles.js'\r\n  import { toTS, videoRx } from '../../../shared/util.js'\r\n  import anitomyscript from 'anitomyscript'\r\n  import { URLFile } from '../../../shared/URLFile.js'\r\n  import Keybinds, { loadWithDefaults } from 'svelte-keybinds'\r\n  import TrackControls from './player/TrackControls.svelte'\r\n  import CastControls from './player/CastControls.svelte'\r\n  import PopoutControls from './player/PopoutControls.svelte'\r\n  import SeekControls from './player/SeekControls.svelte'\r\n  import Stats from './player/Stats.svelte'\r\n\r\n  export let set = {}\r\n  export let files = []\r\n  $: updateFiles(files)\r\n  export let name = null\r\n  let src = null\r\n  let video = null\r\n  let container = null\r\n  let current = null\r\n  let subs = null\r\n  let duration = 0.1\r\n  let paused = true\r\n  let muted = false\r\n  let videos = []\r\n  let immersed = false\r\n  let buffering = false\r\n  let immerseTimeout = null\r\n  let bufferTimeout = null\r\n  let subHeaders = null\r\n  let pip = false\r\n  let isFullscreen = false\r\n  let ended = false\r\n  let volume = localStorage.getItem('volume') || 1\r\n  let playbackRate = 1\r\n  let currentTime = 0\r\n  export let miniplayer = false\r\n  $: safeduration = (isFinite(duration) ? duration : currentTime) || 0\r\n  $: localStorage.setItem('volume', volume || 0)\r\n  function getFPS () {\r\n    video.fps = new Promise(resolve => {\r\n      let lastmeta = null\r\n      let count = 0\r\n\r\n      function handleFrames (now, metadata) {\r\n        if (count) {\r\n          // resolve on 2nd frame, 1st frame might be a cut-off\r\n          if (lastmeta) {\r\n            const msbf = (metadata.mediaTime - lastmeta.mediaTime) / (metadata.presentedFrames - lastmeta.presentedFrames)\r\n            const rawFPS = (1 / msbf).toFixed(3)\r\n            // this is accurate for mp4, mkv is a few ms off\r\n            if (current.name.endsWith('.mkv')) {\r\n              if (rawFPS < 25 && rawFPS > 22) {\r\n                resolve(23.976)\r\n              } else if (rawFPS < 31 && rawFPS > 28) {\r\n                resolve(29.97)\r\n              } else if (rawFPS < 62 && rawFPS > 58) {\r\n                resolve(59.94)\r\n              } else {\r\n                resolve(rawFPS) // smth went VERY wrong\r\n              }\r\n            } else {\r\n              resolve(rawFPS)\r\n            }\r\n          } else {\r\n            lastmeta = metadata\r\n            video.requestVideoFrameCallback(handleFrames)\r\n          }\r\n        } else {\r\n          count++\r\n          video.requestVideoFrameCallback(handleFrames)\r\n        }\r\n      }\r\n      video.requestVideoFrameCallback(handleFrames)\r\n      playFrame()\r\n    })\r\n  }\r\n\r\n  // plays one frame\r\n  function playFrame () {\r\n    let wasPaused = false\r\n    video.requestVideoFrameCallback(() => {\r\n      if (wasPaused) paused = true\r\n    })\r\n    if (paused) {\r\n      wasPaused = true\r\n      paused = false\r\n    }\r\n  }\r\n\r\n  // document.fullscreenElement isn't reactive\r\n  document.addEventListener('fullscreenchange', () => {\r\n    isFullscreen = !!document.fullscreenElement\r\n  })\r\n\r\n  function handleHeaders () {\r\n    subHeaders = subs?.headers\r\n  }\r\n\r\n  function updateFiles (files) {\r\n    if (files?.length) {\r\n      videos = files.filter(file => videoRx.test(file.name))\r\n      if (videos?.length) {\r\n        if (!current) {\r\n          handleCurrent(videos[0])\r\n        } else {\r\n          if (subs) {\r\n            subs.files = files || []\r\n            subs.findSubtitleFiles(current)\r\n          }\r\n        }\r\n      } else {\r\n        src = ''\r\n        video?.load()\r\n        currentTime = 0\r\n        targetTime = 0\r\n      }\r\n    }\r\n  }\r\n\r\n  async function handleCurrent (file) {\r\n    if (file) {\r\n      current = file\r\n      await tick()\r\n      if (thumbnailData.video?.src) URL.revokeObjectURL(video?.src)\r\n      Object.assign(thumbnailData, {\r\n        thumbnails: [],\r\n        interval: undefined,\r\n        video: undefined\r\n      })\r\n      if (file instanceof File || file instanceof URLFile) {\r\n        setFile(file)\r\n        src = `server/${file.name}`\r\n        fast = false\r\n      } else {\r\n        setFile(null)\r\n        src = file.url\r\n        fast = true\r\n      }\r\n      currentTime = 0\r\n      targetTime = 0\r\n      video.load()\r\n      initSubs()\r\n    }\r\n  }\r\n\r\n  function initSubs () {\r\n    if (subs) subs.destroy()\r\n    subs = new Subtitles(video, files, current, handleHeaders)\r\n  }\r\n  function cycleSubtitles () {\r\n    if (current && subs?.headers) {\r\n      const tracks = subs.headers.filter(header => header)\r\n      const index = tracks.indexOf(subs.headers[subs.current]) + 1\r\n      subs.selectCaptions(index >= tracks.length ? -1 : subs.headers.indexOf(tracks[index]))\r\n    }\r\n  }\r\n  $: targetTime = (!paused && currentTime) || targetTime\r\n\r\n  function autoPlay () {\r\n    if (!miniplayer) video.play()\r\n  }\r\n  function playPause () {\r\n    paused = !paused\r\n  }\r\n  function toggleMute () {\r\n    muted = !muted\r\n  }\r\n  let visibilityPaused = true\r\n  document.addEventListener('visibilitychange', () => {\r\n    if (!video?.ended && set.playerPause && !pip) {\r\n      if (document.visibilityState === 'hidden') {\r\n        visibilityPaused = paused\r\n        paused = true\r\n      } else {\r\n        if (!visibilityPaused) paused = false\r\n      }\r\n    }\r\n  })\r\n  function tryPlayNext () {\r\n    if (set.playerAutoplay) playNext()\r\n  }\r\n  function playNext () {\r\n    handleCurrent(videos[(videos.indexOf(current) + 1) % videos.length])\r\n  }\r\n  function playLast () {\r\n    const index = videos.indexOf(current)\r\n    handleCurrent(videos[index === 0 ? videos.length - 1 : index - 1])\r\n  }\r\n  function toggleFullscreen () {\r\n    document.fullscreenElement ? document.exitFullscreen() : container.requestFullscreen()\r\n  }\r\n  function seek (time) {\r\n    if (time === 85 && currentTime < 10) {\r\n      currentTime = currentTime = 90\r\n    } else if (time === 85 && safeduration - currentTime < 90) {\r\n      currentTime = currentTime = safeduration\r\n    } else {\r\n      currentTime = currentTime += time\r\n    }\r\n    targetTime = currentTime\r\n  }\r\n  function forward () {\r\n    seek(2)\r\n  }\r\n  function rewind () {\r\n    seek(-2)\r\n  }\r\n  async function screenshot () {\r\n    if ('clipboard' in navigator) {\r\n      const canvas = document.createElement('canvas')\r\n      const context = canvas.getContext('2d')\r\n      canvas.width = video.videoWidth\r\n      canvas.height = video.videoHeight\r\n      context.drawImage(video, 0, 0)\r\n      if (subs?.renderer) {\r\n        subs.renderer.resize(video.videoWidth, video.videoHeight)\r\n        await new Promise(resolve => setTimeout(resolve, 600)) // this is hacky, but TLDR wait for canvas to update and re-render, in practice this will take at MOST 100ms, but just to be safe\r\n        context.drawImage(subs.renderer._canvas, 0, 0, canvas.width, canvas.height)\r\n        subs.renderer.resize(0, 0, 0, 0) // undo resize\r\n      }\r\n      const blob = await new Promise(resolve => canvas.toBlob(resolve))\r\n      await navigator.clipboard.write([\r\n        new ClipboardItem({\r\n          [blob.type]: blob\r\n        })\r\n      ])\r\n      canvas.remove()\r\n    }\r\n  }\r\n  let togglePopout\r\n  let toggleCast\r\n  let showKeybinds = false\r\n  loadWithDefaults({\r\n    KeyX: {\r\n      fn: () => screenshot(),\r\n      id: 'screenshot_monitor',\r\n      type: 'icon'\r\n    },\r\n    KeyR: {\r\n      fn: () => seek(-90),\r\n      id: '-90'\r\n    },\r\n    Comma: {\r\n      fn: async () => seek(-1 / (await video.fps) || 0),\r\n      id: 'fast_rewind',\r\n      type: 'icon'\r\n    },\r\n    Period: {\r\n      fn: async () => seek(1 / (await video.fps) || 0),\r\n      id: 'fast_forward',\r\n      type: 'icon'\r\n    },\r\n    KeyI: {\r\n      fn: () => toggleStats(),\r\n      id: 'list',\r\n      type: 'icon'\r\n    },\r\n    Backquote: {\r\n      fn: () => (showKeybinds = !showKeybinds),\r\n      id: 'help_outline',\r\n      type: 'icon'\r\n    },\r\n    Space: {\r\n      fn: () => playPause(),\r\n      id: 'play_arrow',\r\n      type: 'icon'\r\n    },\r\n    KeyN: {\r\n      fn: () => playNext(),\r\n      id: 'skip_next',\r\n      type: 'icon'\r\n    },\r\n    KeyM: {\r\n      fn: () => (muted = !muted),\r\n      id: 'volume_off',\r\n      type: 'icon'\r\n    },\r\n    KeyP: {\r\n      fn: () => togglePopout(),\r\n      id: 'picture_in_picture',\r\n      type: 'icon'\r\n    },\r\n    KeyF: {\r\n      fn: () => toggleFullscreen(),\r\n      id: 'fullscreen',\r\n      type: 'icon'\r\n    },\r\n    KeyS: {\r\n      fn: () => seek(85),\r\n      id: '+90'\r\n    },\r\n    KeyD: {\r\n      fn: () => toggleCast(),\r\n      id: 'cast',\r\n      type: 'icon'\r\n    },\r\n    KeyC: {\r\n      fn: () => cycleSubtitles(),\r\n      id: 'subtitles',\r\n      type: 'icon'\r\n    },\r\n    ArrowLeft: {\r\n      fn: () => rewind(),\r\n      id: '-2'\r\n    },\r\n    ArrowRight: {\r\n      fn: () => forward(),\r\n      id: '+2'\r\n    },\r\n    ArrowUp: {\r\n      fn: () => (volume = Math.min(1, volume + 0.05)),\r\n      id: 'volume_up',\r\n      type: 'icon'\r\n    },\r\n    ArrowDown: {\r\n      fn: () => (volume = Math.max(0, volume - 0.05)),\r\n      id: 'volume_down',\r\n      type: 'icon'\r\n    },\r\n    BracketLeft: {\r\n      fn: () => (playbackRate -= 0.1),\r\n      id: 'history',\r\n      type: 'icon'\r\n    },\r\n    BracketRight: {\r\n      fn: () => (playbackRate += 0.1),\r\n      id: 'update',\r\n      type: 'icon'\r\n    },\r\n    Backslash: {\r\n      fn: () => (playbackRate = 1),\r\n      id: 'schedule',\r\n      type: 'icon'\r\n    }\r\n  })\r\n\r\n  function immersePlayer () {\r\n    immersed = true\r\n    immerseTimeout = undefined\r\n  }\r\n\r\n  function resetImmerse () {\r\n    if (immerseTimeout) {\r\n      clearTimeout(immerseTimeout)\r\n    } else {\r\n      immersed = false\r\n    }\r\n    immerseTimeout = setTimeout(immersePlayer, 8 * 1000)\r\n  }\r\n\r\n  function hideBuffering () {\r\n    if (bufferTimeout) {\r\n      clearTimeout(bufferTimeout)\r\n      bufferTimeout = null\r\n      buffering = false\r\n    }\r\n  }\r\n\r\n  function showBuffering () {\r\n    bufferTimeout = setTimeout(() => {\r\n      buffering = true\r\n      resetImmerse()\r\n    }, 150)\r\n  }\r\n  $: navigator.mediaSession?.setPositionState({\r\n    duration: Math.max(0, safeduration),\r\n    playbackRate: 1,\r\n    position: Math.max(0, Math.min(safeduration, currentTime || 0))\r\n  })\r\n\r\n  async function mediaChange (current, image) {\r\n    if (current) {\r\n      // eslint-disable-next-line camelcase\r\n      const { release_group, anime_title, episode_number, episode_title } = await anitomyscript(current.name)\r\n      // honestly, this is made for anime, but works fantastic for everything else.\r\n      // eslint-disable-next-line camelcase\r\n      name = [anime_title, episode_number, episode_title].filter(i => i).join(' - ')\r\n      if ('mediaSession' in navigator) {\r\n        const metadata = image\r\n          ? new MediaMetadata({\r\n            title: name || 'Video Player',\r\n            artwork: [\r\n              {\r\n                src: image,\r\n                sizes: '256x256',\r\n                type: 'image/jpg'\r\n              }\r\n            ]\r\n          })\r\n          : new MediaMetadata({\r\n            title: name || 'Video Player'\r\n          })\r\n        // eslint-disable-next-line camelcase\r\n        if (release_group) metadata.artist = release_group\r\n        navigator.mediaSession.metadata = metadata\r\n      }\r\n    }\r\n  }\r\n  $: mediaChange(current)\r\n\r\n  if ('mediaSession' in navigator) {\r\n    navigator.mediaSession.setActionHandler('play', playPause)\r\n    navigator.mediaSession.setActionHandler('pause', playPause)\r\n    navigator.mediaSession.setActionHandler('nexttrack', playNext)\r\n    navigator.mediaSession.setActionHandler('previoustrack', playLast)\r\n    navigator.mediaSession.setActionHandler('seekforward', forward)\r\n    navigator.mediaSession.setActionHandler('seekbackward', rewind)\r\n  }\r\n  let toggleStats\r\n  let fast = false\r\n  let successCount = 0\r\n  async function checkSpeed () {\r\n    if (!fast && (current instanceof File || current instanceof URLFile) && safeduration) {\r\n      const byterate = current.size / safeduration\r\n      const currBps = speed()\r\n      if (currBps > 5 * byterate) {\r\n        ++successCount\r\n        // this is faulty logic, because there might not be a need to pull data, even if the speeds can be reached\r\n        if (successCount > 10) {\r\n          console.log('Access speed exceeds x5 bitrate')\r\n          fast = true\r\n          await subs?.parseSubtitles()\r\n          finishThumbnails()\r\n        }\r\n      } else {\r\n        successCount = 0\r\n      }\r\n    }\r\n  }\r\n  const thumbCanvas = document.createElement('canvas')\r\n  thumbCanvas.width = 200\r\n  const thumbnailData = {\r\n    thumbnails: [],\r\n    canvas: thumbCanvas,\r\n    context: thumbCanvas.getContext('2d'),\r\n    interval: Number.MAX_VALUE,\r\n    video: null\r\n  }\r\n  function createThumbnail (vid = video) {\r\n    if (vid?.readyState >= 2 && (current instanceof File || current instanceof URLFile)) {\r\n      const index = Math.floor(vid.currentTime / thumbnailData.interval)\r\n      if (!thumbnailData.thumbnails[index]) {\r\n        thumbnailData.context.fillRect(0, 0, 200, thumbnailData.canvas.height)\r\n        thumbnailData.context.drawImage(vid, 0, 0, 200, thumbnailData.canvas.height)\r\n        thumbnailData.thumbnails[index] = thumbnailData.canvas.toDataURL('image/jpeg')\r\n        if (index === 5) mediaChange(current, thumbnailData.thumbnails[index])\r\n      }\r\n    }\r\n  }\r\n  let videoWidth, videoHeight\r\n  $: initThumbnails(200 / (videoWidth / videoHeight))\r\n  function initThumbnails (height) {\r\n    if (!isNaN(height)) {\r\n      thumbnailData.interval = safeduration / 300 < 5 ? 5 : safeduration / 300\r\n      thumbnailData.canvas.height = height\r\n    }\r\n  }\r\n\r\n  function finishThumbnails () {\r\n    const t0 = performance.now()\r\n    const video = document.createElement('video')\r\n    let index = 0\r\n    video.preload = 'none'\r\n    video.volume = 0\r\n    video.playbackRate = 0\r\n    video.addEventListener('loadeddata', () => loadTime())\r\n    video.addEventListener('canplay', () => {\r\n      createThumbnail(thumbnailData.video)\r\n      loadTime()\r\n    })\r\n    thumbnailData.video = video\r\n    const loadTime = () => {\r\n      while (thumbnailData.thumbnails[index] && index <= Math.floor(safeduration / thumbnailData.interval)) {\r\n        // only create thumbnails that are missing\r\n        index++\r\n      }\r\n      if (thumbnailData.video?.currentTime !== safeduration && thumbnailData.video) {\r\n        thumbnailData.video.currentTime = index * thumbnailData.interval || Number.MAX_VALUE\r\n      } else {\r\n        thumbnailData.video?.removeAttribute('src')\r\n        thumbnailData.video?.load()\r\n        thumbnailData.video?.remove()\r\n        delete thumbnailData.video\r\n        console.log('Thumbnail creating finished', index, toTS((performance.now() - t0) / 1000))\r\n      }\r\n      index++\r\n    }\r\n    thumbnailData.video.src = current instanceof File ? URL.createObjectURL(current) : current.url\r\n    thumbnailData.video.load()\r\n    console.log('Thumbnail creating started')\r\n  }\r\n  let isStandalone = window.matchMedia('(display-mode: standalone)').matches\r\n  window.matchMedia('(display-mode: standalone)').addEventListener('change', ({ matches }) => {\r\n    isStandalone = matches\r\n  })\r\n  const isWindows = navigator.appVersion.includes('Windows')\r\n  let innerWidth, innerHeight\r\n  let menubarOffset = 0\r\n  $: calcMenubarOffset(innerWidth, innerHeight, videoWidth, videoHeight, isStandalone)\r\n  function calcMenubarOffset (innerWidth, innerHeight, videoWidth, videoHeight, isStandalone) {\r\n    // outerheight resize and innerheight resize is mutual, additionally update on metadata and app state change\r\n    if (isStandalone && videoWidth && videoHeight) {\r\n      // so windows is very dumb, and calculates windowed mode as if it was window XP, with the old bars, but not when maximised\r\n      const isMaximised = screen.availWidth === window.outerWidth && screen.availHeight === window.outerHeight\r\n      const menubar = Math.max(0, isWindows && !isMaximised ? window.outerHeight - innerHeight - 8 : window.outerHeight - innerHeight)\r\n      // element ratio calc\r\n      const videoRatio = videoWidth / videoHeight\r\n      const { offsetWidth, offsetHeight } = video\r\n      const elementRatio = offsetWidth / offsetHeight\r\n      // video is shorter than element && has space for menubar offset\r\n      if (!document.fullscreenElement && menubar && elementRatio <= videoRatio && offsetHeight - offsetWidth / videoRatio > menubar) {\r\n        menubarOffset = (menubar / 2) * -1\r\n      } else {\r\n        menubarOffset = 0\r\n      }\r\n    }\r\n  }\r\n\r\n</script>\r\n\r\n<svelte:window bind:innerWidth bind:innerHeight />\r\n{#if showKeybinds}\r\n  <div class='position-absolute bg-tp w-full h-full z-50 font-size-12 p-20 d-flex align-items-center justify-content-center' on:click|self={() => (showKeybinds = false)}>\r\n    <button class='close' type='button' on:click={() => (showKeybinds = false)}><span>×</span></button>\r\n    <Keybinds let:prop={item} autosave={true} clickable={true}>\r\n      <div class:material-icons={item?.type} class='bind'>{item?.id || ''}</div>\r\n    </Keybinds>\r\n  </div>\r\n{/if}\r\n<div\r\n  class='player w-full h-full d-flex flex-column overflow-hidden position-relative'\r\n  class:pointer={miniplayer}\r\n  class:miniplayer\r\n  class:pip\r\n  class:immersed\r\n  class:buffering\r\n  bind:this={container}\r\n  on:mousemove={resetImmerse}\r\n  on:touchmove={resetImmerse}\r\n  on:keypress={resetImmerse}\r\n  on:mouseleave={immersePlayer}>\r\n  <!-- eslint-disable-next-line svelte/valid-compile -->\r\n  <video\r\n    class='position-absolute h-full w-full'\r\n    style={`margin-top: ${menubarOffset}px`}\r\n    autoplay\r\n    preload='auto'\r\n    {src}\r\n    bind:videoHeight\r\n    bind:videoWidth\r\n    bind:this={video}\r\n    bind:volume\r\n    bind:duration\r\n    bind:currentTime\r\n    bind:paused\r\n    bind:ended\r\n    bind:muted\r\n    bind:playbackRate\r\n    on:timeupdate={checkSpeed}\r\n    on:timeupdate={() => createThumbnail()}\r\n    on:waiting={showBuffering}\r\n    on:loadeddata={hideBuffering}\r\n    on:canplay={hideBuffering}\r\n    on:playing={hideBuffering}\r\n    on:loadedmetadata={hideBuffering}\r\n    on:ended={tryPlayNext}\r\n    on:loadedmetadata={getFPS}\r\n    on:loadedmetadata={initThumbnails}\r\n    on:loadedmetadata={autoPlay}\r\n    on:leavepictureinpicture={() => (pip = false)} />\r\n  <Stats {video} bind:toggleStats />\r\n  <div class='top z-40 d-flex justify-content-between'>\r\n    <div />\r\n    <div />\r\n    <span class='material-icons ctrl' title='Keybinds [`]' on:click={() => (showKeybinds = true)}> help_outline </span>\r\n  </div>\r\n  <div class='middle d-flex align-items-center justify-content-center flex-grow-1 z-40 position-relative'>\r\n    <div class='position-absolute w-full h-full' on:dblclick={toggleFullscreen}>\r\n      <div class='play-overlay w-full h-full' on:click={playPause} />\r\n    </div>\r\n    <span class='material-icons ctrl' class:text-muted={!videos?.length > 1} class:disabled={!videos?.length > 1} data-name='playLast' on:click={playLast}> skip_previous </span>\r\n    <span class='material-icons ctrl' data-name='rewind' on:click={rewind}> fast_rewind </span>\r\n    <span class='material-icons ctrl' data-name='playPause' on:click={playPause}> {ended ? 'replay' : paused ? 'play_arrow' : 'pause'} </span>\r\n    <span class='material-icons ctrl' data-name='forward' on:click={forward}> fast_forward </span>\r\n    <span class='material-icons ctrl' class:text-muted={!videos?.length > 1} class:disabled={!videos?.length > 1} data-name='playNext' on:click={playNext}> skip_next </span>\r\n    <div data-name='bufferingDisplay' class='position-absolute' />\r\n  </div>\r\n  <div class='bottom d-flex z-40 flex-column px-20'>\r\n    <SeekControls bind:currentTime bind:targetTime {safeduration} {thumbnailData} bind:paused />\r\n    <div class='d-flex'>\r\n      <span class='material-icons ctrl' title='Play/Pause [Space]' data-name='playPause' on:click={playPause}> {ended ? 'replay' : paused ? 'play_arrow' : 'pause'} </span>\r\n      {#if videos?.length > 1}\r\n        <span class='material-icons ctrl' title='Next [N]' data-name='playNext' on:click={playNext}> skip_next </span>\r\n      {/if}\r\n      <div class='d-flex w-auto volume'>\r\n        <span class='material-icons ctrl' title='Mute [M]' data-name='toggleMute' on:click={toggleMute}> {muted ? 'volume_off' : 'volume_up'} </span>\r\n        <input class='ctrl' type='range' min='0' max='1' step='any' data-name='setVolume' bind:value={volume} style='--value: {volume * 100}%' />\r\n      </div>\r\n      <div class='ts mr-auto'>{toTS(targetTime, safeduration > 3600 ? 2 : 3)} / {toTS(safeduration - targetTime, safeduration > 3600 ? 2 : 3)}</div>\r\n      <TrackControls {video} {subs} {subHeaders} />\r\n      <CastControls {video} {subs} bind:paused bind:toggleCast {container} />\r\n      <PopoutControls {video} {subs} bind:pip bind:togglePopout {container} />\r\n      <span class='material-icons ctrl' title='Fullscreen [F]' data-name='toggleFullscreen' on:click={toggleFullscreen}>\r\n        {isFullscreen ? 'fullscreen_exit' : 'fullscreen'}\r\n      </span>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<style>\r\n  .bind {\r\n    font-size: 1.8rem;\r\n    font-weight: bold;\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n    height: 100%;\r\n  }\r\n  .bind.material-icons {\r\n    font-size: 2.2rem !important;\r\n    font-weight: unset !important;\r\n  }\r\n  .miniplayer {\r\n    height: auto !important;\r\n  }\r\n  .miniplayer .top,\r\n  .miniplayer .bottom {\r\n    display: none !important;\r\n  }\r\n  .miniplayer video {\r\n    position: relative !important;\r\n  }\r\n  .bg-tp {\r\n    background: #000000bb;\r\n    backdrop-filter: blur(10px);\r\n  }\r\n  .bg-tp .close {\r\n    position: absolute;\r\n    top: 0;\r\n    right: 0;\r\n    cursor: pointer;\r\n    color: inherit;\r\n    padding: var(--alert-close-padding);\r\n    line-height: var(--alert-close-line-height);\r\n    font-size: var(--alert-close-font-size);\r\n    background-color: transparent;\r\n    border-color: transparent;\r\n  }\r\n\r\n  video {\r\n    transition: margin-top 0.2s ease;\r\n  }\r\n  .player {\r\n    user-select: none;\r\n    font-family: Roboto, Arial, Helvetica, sans-serif;\r\n    background-color: var(--dark-color-light);\r\n    will-change: width;\r\n    background: #000;\r\n  }\r\n  .player.miniplayer {\r\n    background: #00000066;\r\n    backdrop-filter: blur(3px);\r\n  }\r\n\r\n  .pip :global(canvas:not(.w-full)) {\r\n    width: 1px !important;\r\n    height: 1px !important;\r\n    /*hack to hide the canvas but still keep it updating*/\r\n  }\r\n\r\n  .material-icons {\r\n    font-size: 2.6rem;\r\n    padding: 1.5rem;\r\n    display: flex;\r\n  }\r\n\r\n  .immersed {\r\n    cursor: none;\r\n  }\r\n\r\n  .immersed .middle .ctrl,\r\n  .immersed .top,\r\n  .immersed .bottom {\r\n    opacity: 0;\r\n  }\r\n\r\n  .pip video {\r\n    opacity: 0.1%\r\n  }\r\n\r\n  .middle div[data-name='bufferingDisplay'] {\r\n    border: 4px solid #ffffff00;\r\n    border-top: 4px solid #fff;\r\n    border-radius: 50%;\r\n    width: 40px;\r\n    height: 40px;\r\n    animation: spin 1s linear infinite;\r\n    opacity: 0;\r\n    transition: 0.5s opacity ease;\r\n    filter: drop-shadow(0 0 8px #000);\r\n  }\r\n  .disabled {\r\n    cursor: not-allowed !important;\r\n  }\r\n\r\n  .buffering .middle div[data-name='bufferingDisplay'] {\r\n    opacity: 1 !important;\r\n  }\r\n\r\n  @keyframes spin {\r\n    0% {\r\n      transform: rotate(0deg);\r\n    }\r\n\r\n    100% {\r\n      transform: rotate(360deg);\r\n    }\r\n  }\r\n\r\n  .middle .ctrl {\r\n    font-size: 4rem;\r\n    margin: 2rem;\r\n    z-index: 3;\r\n    display: none;\r\n  }\r\n  :fullscreen {\r\n    background: #000 !important;\r\n  }\r\n\r\n  @media (pointer: none), (pointer: coarse) {\r\n    .middle .ctrl {\r\n      display: flex;\r\n    }\r\n    .middle .play-overlay {\r\n      display: none !important;\r\n    }\r\n  }\r\n  .miniplayer .middle {\r\n    transition: background 0.2s ease;\r\n    position: absolute !important;\r\n    width: 100%;\r\n    height: 100%;\r\n  }\r\n  .miniplayer .middle .ctrl {\r\n    display: flex;\r\n    font-size: 2.8rem;\r\n    margin: 0.6rem;\r\n  }\r\n  .miniplayer .middle .play-overlay {\r\n    display: none !important;\r\n  }\r\n  .miniplayer .middle .ctrl[data-name='playPause'] {\r\n    font-size: 5.625rem;\r\n  }\r\n  .miniplayer:hover .middle {\r\n    background: #00000066;\r\n  }\r\n  .middle .ctrl[data-name='playPause'] {\r\n    font-size: 6.75rem;\r\n  }\r\n\r\n  .middle .ctrl,\r\n  .bottom .ctrl:hover,\r\n  .bottom .ts:hover,\r\n  .bottom .hover .ts {\r\n    filter: drop-shadow(0 0 8px #000);\r\n  }\r\n\r\n  .bottom {\r\n    padding-top: 3rem;\r\n    background: linear-gradient(to top, rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0.6) 25%, rgba(0, 0, 0, 0.4) 65%, rgba(0, 0, 0, 0.1) 90%, transparent);\r\n    transition: 0.5s opacity ease;\r\n  }\r\n  .top {\r\n    background: linear-gradient(to bottom, rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0.4) 25%, rgba(0, 0, 0, 0.2) 50%, rgba(0, 0, 0, 0.1) 75%, transparent);\r\n    transition: 0.5s opacity ease;\r\n  }\r\n\r\n  .ctrl {\r\n    cursor: pointer;\r\n  }\r\n\r\n  input[type='range'] {\r\n    -webkit-appearance: none;\r\n    background: transparent;\r\n    margin: 0;\r\n    cursor: pointer;\r\n    height: 8px;\r\n  }\r\n\r\n  input[type='range']:focus {\r\n    outline: none;\r\n  }\r\n\r\n  input[type='range']::-webkit-slider-runnable-track {\r\n    height: 3px;\r\n  }\r\n\r\n  input[type='range']::-moz-range-track {\r\n    height: 3px;\r\n    border: none;\r\n  }\r\n\r\n  input[type='range']::-webkit-slider-thumb {\r\n    height: 0;\r\n    width: 0;\r\n    border-radius: 50%;\r\n    background: #ff3c00;\r\n    -webkit-appearance: none;\r\n    appearance: none;\r\n    transition: all 0.1s ease;\r\n  }\r\n  input[type='range']::-moz-range-thumb {\r\n    height: 0;\r\n    width: 0;\r\n    border-radius: 50%;\r\n    background: #ff3c00;\r\n    -webkit-appearance: none;\r\n    appearance: none;\r\n    transition: all 0.1s ease;\r\n    border: none;\r\n  }\r\n\r\n  input[type='range']:hover::-webkit-slider-thumb {\r\n    height: 12px;\r\n    width: 12px;\r\n    margin-top: -4px;\r\n  }\r\n\r\n  input[type='range']:hover::-moz-range-thumb {\r\n    height: 12px;\r\n    width: 12px;\r\n    margin-top: -4px;\r\n  }\r\n\r\n  input[type='range']::-moz-range-track {\r\n    background: linear-gradient(90deg, #ff3c00 var(--value), rgba(255, 255, 255, 0.2) var(--value));\r\n  }\r\n  input[type='range']::-webkit-slider-runnable-track {\r\n    background: linear-gradient(90deg, #ff3c00 var(--value), rgba(255, 255, 255, 0.2) var(--value));\r\n  }\r\n  .bottom .volume:hover input[type='range'] {\r\n    width: 5vw;\r\n    display: inline-block;\r\n    margin-right: 1.125rem;\r\n  }\r\n\r\n  .bottom .volume input[type='range'] {\r\n    width: 0;\r\n    transition: width 0.1s ease;\r\n    height: 100%;\r\n  }\r\n\r\n  .bottom .ts {\r\n    color: #ececec;\r\n    font-size: 2rem !important;\r\n    white-space: nowrap;\r\n    align-self: center;\r\n    line-height: var(--base-line-height);\r\n    padding: 0 1.56rem;\r\n    font-weight: 600;\r\n  }\r\n\r\n  @media (pointer: none), (pointer: coarse) {\r\n    .bottom .ctrl[data-name='playPause'],\r\n    .bottom .ctrl[data-name='playNext'],\r\n    .bottom .volume,\r\n    .bottom .ctrl[data-name='toggleFullscreen'] {\r\n      display: none;\r\n    }\r\n  }\r\n</style>\r\n","<script>\r\n  let deferredPrompt\r\n\r\n  window.addEventListener('beforeinstallprompt', e => {\r\n    e.preventDefault()\r\n    deferredPrompt = e\r\n  })\r\n  async function promptInstall () {\r\n    deferredPrompt.prompt()\r\n    const { outcome } = await deferredPrompt.userChoice\r\n    if (outcome === 'accepted') {\r\n      deferredPrompt = null\r\n    }\r\n  }\r\n  function dismiss () {\r\n    deferredPrompt = null\r\n  }\r\n</script>\r\n\r\n{#if deferredPrompt}\r\n  <div class=\"alert alert-success filled-dm show\" on:click={promptInstall}>\r\n    <h4 class=\"alert-heading\">Install</h4>\r\n    <button class=\"close\" type=\"button\" on:click={dismiss}><span>×</span></button>\r\n    Click here to install the app for more features!\r\n  </div>\r\n{/if}\r\n\r\n<style>\r\n  .alert {\r\n    display: block !important;\r\n    animation: fly-in 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);\r\n  }\r\n\r\n  @keyframes fly-in {\r\n    0% {\r\n      right: -50rem;\r\n    }\r\n    100% {\r\n      right: 0;\r\n    }\r\n  }\r\n</style>\r\n","<script context='module'>\r\n  import { get, set, createStore } from 'idb-keyval'\r\n\r\n  const supported = 'FileSystemFileHandle' in window\r\n\r\n  const asyncSome = async (arr, predicate) => {\r\n    for (const e of arr) {\r\n      if (await predicate(e)) return true\r\n    }\r\n    return false\r\n  }\r\n  const asyncFilter = async (arr, predicate) => {\r\n    const results = await Promise.all(arr.map(predicate))\r\n\r\n    return arr.filter((_v, index) => results[index])\r\n  }\r\n\r\n  let db = null\r\n  async function setHandles () {\r\n    handles = (await get('recents', db)) || []\r\n  }\r\n  export function initDb (appName) {\r\n    db = createStore(appName, 'recents')\r\n  }\r\n\r\n  let handles = []\r\n\r\n  // this is clunky, but dataTransfer doesn't persist across async calls.... https://stackoverflow.com/questions/55658851\r\n  export async function updateRecents (files) {\r\n    if (supported && db && files?.length) {\r\n      const promises = files\r\n        .map(file => (file instanceof FileSystemFileHandle ? file : file.getAsFileSystemHandle()))\r\n        .filter(file => file instanceof FileSystemFileHandle || file instanceof File)\r\n      if (!promises.length) return null\r\n      const newHandles = await Promise.all(promises)\r\n      await setHandles()\r\n      handles = await asyncFilter(handles, async handle => {\r\n        return !(await asyncSome(newHandles, recent => recent.isSameEntry(handle)))\r\n      })\r\n      handles.unshift(...newHandles)\r\n      handles.length = Math.min(handles.length, 15)\r\n      set('recents', handles, db)\r\n    }\r\n  }\r\n</script>\r\n\r\n<script>\r\n  export let files = null\r\n  let recents = []\r\n  setHandles().then(() => {\r\n    recents = handles\r\n  })\r\n  async function selectFile (handle) {\r\n    updateRecents([handle])\r\n    await handle.requestPermission({ mode: 'read' })\r\n    files = [await handle.getFile()]\r\n  }\r\n\r\n  export let handlePopup = () => {}\r\n</script>\r\n\r\n<div class='h-full my-0 bg-very-dark'>\r\n  <div class='container h-full p-20'>\r\n    <div class='p-20 d-flex flex-column h-full'>\r\n      <div class='font-weight-bold font-size-24 p-5'>Recent Files</div>\r\n      <hr class='w-full my-15' />\r\n      <div class='overflow-y-auto'>\r\n        {#if supported}\r\n          {#each recents as recent}\r\n            <div class='p-5 pointer text-muted hover' on:click={selectFile(recent)}>\r\n              <div class='ml-5'>{recent.name}</div>\r\n            </div>\r\n          {:else}\r\n            <div class='ml-5 p-5'>Your recent files will show up here!</div>\r\n          {/each}\r\n        {:else if window.chrome}\r\n          <div>\r\n            Your browser doesn't support recent files, but it could! Visit <code class='code'>chrome://flags</code> and enable <code class='code'>#file-system-access-api!</code>\r\n          </div>\r\n        {:else}\r\n          <div>Your browser doesn't support recent files.</div>\r\n        {/if}\r\n      </div>\r\n      <div class='py-20 pointer text-muted hover mt-auto' on:click={handlePopup}>You can also drag-drop or paste files, or click here to select some!</div>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<style>\r\n  .pointer {\r\n    cursor: pointer;\r\n  }\r\n  .hover:hover {\r\n    color: #fff !important;\r\n  }\r\n</style>\r\n","<script>\r\n  import Player from './modules/Player.svelte'\r\n  import InstallPrompt from '../../shared/InstallPrompt.svelte'\r\n  import { filePopup, handleItems, getSearchFiles, getLaunchFiles } from '../../shared/inputHandler.js'\r\n  import { URLFile } from '../../shared/URLFile.js'\r\n  import RecentFiles, { initDb } from '../../shared/RecentFiles.svelte'\r\n\r\n  initDb('video-player')\r\n\r\n  let name = ''\r\n  let files = []\r\n\r\n  // mistakes have been made\r\n  if (navigator.serviceWorker?.controller?.scriptURL.endsWith('server-worker.js')) {\r\n    navigator.serviceWorker.ready.then(reg => {\r\n      reg.unregister().then(() => location.reload())\r\n    })\r\n  }\r\n\r\n  // loading files\r\n  async function handleInput ({ dataTransfer, clipboardData }) {\r\n    const items = clipboardData?.items || dataTransfer?.items\r\n    if (items) {\r\n      handleFiles(await handleItems(items, ['video', 'subtitle']))\r\n    }\r\n  }\r\n\r\n  if ('launchQueue' in window) {\r\n    getLaunchFiles().then(handleFiles)\r\n  }\r\n  async function handlePopup () {\r\n    if (!files.length) {\r\n      handleFiles(await filePopup(['video', 'subtitle']))\r\n    }\r\n  }\r\n  async function handleFiles (newfiles) {\r\n    if (newfiles?.length) {\r\n      files = files.concat(\r\n        await Promise.all(\r\n          newfiles.map(async file => {\r\n            if (file instanceof File) return file\r\n            const urlfile = new URLFile(file)\r\n            if (!((await urlfile.ready) instanceof Error)) {\r\n              return urlfile\r\n            }\r\n            return file\r\n          })\r\n        )\r\n      )\r\n    }\r\n  }\r\n  handleFiles(getSearchFiles(['video', 'subtitle']))\r\n</script>\r\n\r\n<div class='sticky-alerts d-flex flex-column-reverse'>\r\n  <InstallPrompt />\r\n</div>\r\n<div class='page-wrapper'>\r\n  {#if !files.length}\r\n    <RecentFiles bind:files {handlePopup} />\r\n  {:else}\r\n    <Player bind:files bind:name />\r\n  {/if}\r\n</div>\r\n\r\n<svelte:head>\r\n  <title>{name || 'Video Player'}</title>\r\n</svelte:head>\r\n\r\n<svelte:window on:drop|preventDefault={handleInput} on:dragover|preventDefault on:paste|preventDefault={handleInput} />\r\n\r\n<style>\r\n  * {\r\n    user-select: none;\r\n  }\r\n  .sticky-alerts {\r\n    --sticky-alerts-top: auto;\r\n    bottom: 1rem;\r\n  }\r\n</style>\r\n"],"names":[],"sourceRoot":""}