{"version":3,"file":"build/bundle.css","mappings":"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","sources":["webpack://svelte-app/./src/modules/Player.svelte","webpack://svelte-app/./src/App.svelte"],"sourcesContent":["<script>\r\n  import { onMount } from 'svelte'\r\n  import { setFile } from './server.js'\r\n  import Peer from '../lib/peer.js'\r\n  import './File.js'\r\n  import Subtitles from './subtitles.js'\r\n  import { toTS, videoRx, requestTimeout, cancelTimeout } from './util.js'\r\n  import anitomyscript from 'anitomyscript'\r\n\r\n  $: updateFiles(files)\r\n  export let files = []\r\n  export let name = null\r\n  let src = null\r\n  let video = null\r\n  let container = null\r\n  let current = null\r\n  let subs = null\r\n  let duration = 0.1\r\n  let currentTime = 0\r\n  let paused = true\r\n  let muted = false\r\n  let wasPaused = true\r\n  let thumbnail = ' '\r\n  let videos = []\r\n  let immersed = false\r\n  let buffering = false\r\n  let immerseTimeout = null\r\n  let bufferTimeout = null\r\n  let subHeaders = null\r\n  let pip = false\r\n  let presentationRequest = null\r\n  let presentationConnection = null\r\n  let canCast = false\r\n  let isFullscreen = false\r\n  $: progress = currentTime / duration\r\n  $: targetTime = currentTime\r\n  let volume = localStorage.getItem('volume') || 1\r\n  $: localStorage.setItem('volume', volume)\r\n  onMount(() => {\r\n    video.fps = 23.976\r\n  })\r\n\r\n  if ('PresentationRequest' in window) {\r\n    const handleAvailability = aval => {\r\n      canCast = !!aval\r\n    }\r\n    presentationRequest = new PresentationRequest(['build/cast.html'])\r\n    presentationRequest.addEventListener('connectionavailable', e => initCast(e))\r\n    navigator.presentation.defaultRequest = presentationRequest\r\n    presentationRequest.getAvailability().then(aval => {\r\n      aval.onchange = e => handleAvailability(e.target.value)\r\n      handleAvailability(aval.value)\r\n    })\r\n  }\r\n\r\n  //document.fullscreenElement isn't reactive\r\n  document.addEventListener('fullscreenchange', () => {\r\n    isFullscreen = !!document.fullscreenElement\r\n  })\r\n\r\n  function handleHeaders() {\r\n    subHeaders = subs?.headers\r\n  }\r\n\r\n  function updateFiles(files) {\r\n    if (files && files.length) {\r\n      if (subs) subs.destroy()\r\n      videos = files.filter(file => videoRx.test(file.name))\r\n      current = videos[0]\r\n      setFile(current)\r\n      subs = new Subtitles(video, files, current, handleHeaders)\r\n      src = `player/${current.name}`\r\n    }\r\n  }\r\n\r\n  function handleMouseDown({ target }) {\r\n    wasPaused = paused\r\n    paused = true\r\n    targetTime = target.value * duration\r\n  }\r\n  function handleMouseUp() {\r\n    paused = wasPaused\r\n    currentTime = targetTime\r\n  }\r\n  function handleProgress({ target }) {\r\n    targetTime = target.value * duration\r\n  }\r\n\r\n  function playPause() {\r\n    paused = !paused\r\n  }\r\n  function toggleMute() {\r\n    muted = !muted\r\n  }\r\n  function playNext() {\r\n    current = files[(files.indexOf(current) + 1) % files.length]\r\n  }\r\n  function playLast() {\r\n    const index = files.indexOf(current)\r\n    current = files[index === 0 ? files.length - 1 : index - 1]\r\n  }\r\n  function toggleFullscreen() {\r\n    document.fullscreenElement ? document.exitFullscreen() : container.requestFullscreen()\r\n  }\r\n  function seek(time) {\r\n    if (time === 85 && currentTime < 10) {\r\n      currentTime = 90\r\n    } else if (time === 85 && duration - currentTime < 90) {\r\n      currentTime = duration\r\n    } else {\r\n      currentTime += time\r\n    }\r\n  }\r\n  function forward() {\r\n    seek(2)\r\n  }\r\n  function rewind() {\r\n    seek(-2)\r\n  }\r\n  function selectAudio(id) {\r\n    if (id !== undefined) {\r\n      for (const track of video.audioTracks) {\r\n        track.enabled = track.id === id\r\n      }\r\n      seek(-0.5) // stupid fix because video freezes up when chaging tracks\r\n    }\r\n  }\r\n  function toggleCast() {\r\n    if (video.readyState) {\r\n      if (presentationConnection) {\r\n        presentationConnection?.terminate()\r\n      } else {\r\n        presentationRequest.start()\r\n      }\r\n    }\r\n  }\r\n  async function togglePopout() {\r\n    if (video.readyState) {\r\n      await video.fps\r\n      if (!subs?.renderer) {\r\n        video !== document.pictureInPictureElement ? video.requestPictureInPicture() : document.exitPictureInPicture()\r\n        pip = !document.pictureInPictureElement\r\n      } else {\r\n        if (document.pictureInPictureElement && !document.pictureInPictureElement.id) {\r\n          // only exit if pip is the custom one, else overwrite existing pip with custom\r\n          document.exitPictureInPicture()\r\n          pip = !!document.pictureInPictureElement\r\n        } else {\r\n          const canvasVideo = document.createElement('video')\r\n          const { stream, destroy } = await getBurnIn()\r\n          canvasVideo.srcObject = stream\r\n          canvasVideo.onloadedmetadata = () => {\r\n            canvasVideo.play()\r\n            canvasVideo\r\n              .requestPictureInPicture()\r\n              .then(() => {\r\n                pip = !!document.pictureInPictureElement\r\n              })\r\n              .catch(e => {\r\n                pip = !!document.pictureInPictureElement\r\n                console.warn('Failed To Burn In Subtitles ' + e)\r\n                destroy()\r\n                canvasVideo.remove()\r\n              })\r\n          }\r\n          canvasVideo.onleavepictureinpicture = () => {\r\n            destroy()\r\n            canvasVideo.remove()\r\n            pip = !!document.pictureInPictureElement\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  function handleKeydown({ key }) {\r\n    switch (key) {\r\n      case ' ':\r\n        playPause()\r\n        break\r\n      case 'n':\r\n        playNext()\r\n        break\r\n      case 'm':\r\n        muted = !muted\r\n        break\r\n      case 'p':\r\n        togglePopout()\r\n        break\r\n      case 'f':\r\n        toggleFullscreen()\r\n        break\r\n      case 's':\r\n        seek(85)\r\n        break\r\n      case 'c':\r\n        toggleCast()\r\n        break\r\n      case 'ArrowLeft':\r\n        rewind()\r\n        break\r\n      case 'ArrowRight':\r\n        forward()\r\n        break\r\n      case 'ArrowUp':\r\n        volume = Math.min(1, volume + 0.05)\r\n        break\r\n      case 'ArrowDown':\r\n        volume = Math.max(0, volume - 0.05)\r\n        break\r\n    }\r\n  }\r\n\r\n  async function getBurnIn(noSubs) {\r\n    const canvas = document.createElement('canvas')\r\n    const context = canvas.getContext('2d', { alpha: false })\r\n    const fps = await video.fps\r\n    let loop = null\r\n    canvas.width = video.videoWidth\r\n    canvas.height = video.videoHeight\r\n\r\n    const renderFrame = async () => {\r\n      context.drawImage(video, 0, 0)\r\n      if (!noSubs) context.drawImage(subs.renderer?.canvas, 0, 0, canvas.width, canvas.height)\r\n      loop = requestTimeout(renderFrame, 500 / fps) // request x2 fps for smoothness\r\n    }\r\n    loop = requestAnimationFrame(renderFrame)\r\n    const destroy = () => {\r\n      cancelTimeout(loop)\r\n      canvas.remove()\r\n    }\r\n    return { stream: canvas.captureStream(), destroy }\r\n  }\r\n\r\n  function initCast(event) {\r\n    let peer = new Peer({ polite: true })\r\n\r\n    presentationConnection = event.connection\r\n    presentationConnection.addEventListener('terminate', () => {\r\n      presentationConnection = null\r\n      pip = false\r\n      peer = null\r\n    })\r\n\r\n    peer.signalingPort.onmessage = ({ data }) => {\r\n      presentationConnection.send(data)\r\n    }\r\n\r\n    presentationConnection.addEventListener('message', ({ data }) => {\r\n      peer.signalingPort.postMessage(data)\r\n    })\r\n\r\n    peer.dc.onopen = async () => {\r\n      await video.fps\r\n      if (peer && presentationConnection) {\r\n        pip = true\r\n        const tracks = []\r\n        const videostream = video.captureStream()\r\n        if (true) {\r\n          // TODO: check if cast supports codecs\r\n          const { stream, destroy } = await getBurnIn(!subs?.renderer)\r\n          tracks.push(stream.getVideoTracks()[0], videostream.getAudioTracks()[0])\r\n          presentationConnection.addEventListener('terminate', destroy)\r\n        } else {\r\n          tracks.push(videostream.getVideoTracks()[0], videostream.getAudioTracks()[0])\r\n        }\r\n        for (const track of tracks) {\r\n          peer.pc.addTrack(track, videostream)\r\n        }\r\n        paused = false // video pauses for some reason\r\n      }\r\n    }\r\n  }\r\n\r\n  function immersePlayer() {\r\n    immersed = true\r\n    immerseTimeout = undefined\r\n  }\r\n\r\n  function resetImmerse() {\r\n    if (immerseTimeout) {\r\n      clearTimeout(immerseTimeout)\r\n    } else {\r\n      immersed = false\r\n    }\r\n    immerseTimeout = setTimeout(immersePlayer, 5 * 1000)\r\n  }\r\n\r\n  function hideBuffering() {\r\n    if (bufferTimeout) {\r\n      clearTimeout(bufferTimeout)\r\n      bufferTimeout = null\r\n      buffering = false\r\n    }\r\n  }\r\n\r\n  function showBuffering() {\r\n    bufferTimeout = setTimeout(() => {\r\n      buffering = true\r\n      resetImmerse()\r\n    }, 150)\r\n  }\r\n\r\n  function resolveFps() {\r\n    if ('requestVideoFrameCallback' in HTMLVideoElement.prototype) {\r\n      video.fps = new Promise(resolve => {\r\n        const resolveFps = () => {\r\n          video.removeEventListener('timeupdate', resolveFps)\r\n          if (!paused) {\r\n            setTimeout(\r\n              () =>\r\n                video.requestVideoFrameCallback((now, metaData) => {\r\n                  let duration = 0\r\n                  for (let index = video.played.length; index--; ) {\r\n                    duration += video.played.end(index) - video.played.start(index)\r\n                  }\r\n                  const rawFPS = metaData.presentedFrames / duration\r\n                  if (rawFPS < 28) {\r\n                    resolve(23.976)\r\n                  } else if (rawFPS <= 35) {\r\n                    resolve(29.97)\r\n                  } else if (rawFPS <= 70) {\r\n                    resolve(59.94)\r\n                  } else {\r\n                    resolve(23.976) // smth went VERY wrong\r\n                  }\r\n                }),\r\n              2000\r\n            )\r\n          }\r\n        }\r\n        video.addEventListener('timeupdate', resolveFps)\r\n      })\r\n    }\r\n  }\r\n  $: navigator.mediaSession?.setPositionState({\r\n    duration: Math.max(0, duration || 0),\r\n    playbackRate: 1,\r\n    position: Math.max(0, currentTime || 0)\r\n  })\r\n  async function mediaChange(current) {\r\n    if (current) {\r\n      const { release_group, anime_title, episode_number } = await anitomyscript(current.name)\r\n      // honestly, this is made for anime, but works fantastic for everything else.\r\n      name = [anime_title, episode_number].filter(i => i).join(' - ')\r\n      if ('mediaSession' in navigator) {\r\n        const metadata = new MediaMetadata({\r\n          title: name || 'Video Player'\r\n          // artwork: [\r\n          //   {\r\n          //     src: null,\r\n          //     sizes: '256x256',\r\n          //     type: 'image/jpg'\r\n          //   }\r\n          // ]\r\n        })\r\n        if (release_group) metadata.artist = release_group\r\n        navigator.mediaSession.metadata = metadata\r\n      }\r\n    }\r\n  }\r\n  $: mediaChange(current)\r\n\r\n  if ('mediaSession' in navigator) {\r\n    navigator.mediaSession.setActionHandler('play', playPause)\r\n    navigator.mediaSession.setActionHandler('pause', playPause)\r\n    navigator.mediaSession.setActionHandler('nexttrack', playNext)\r\n    navigator.mediaSession.setActionHandler('previoustrack', playLast)\r\n    navigator.mediaSession.setActionHandler('seekforward', forward)\r\n    navigator.mediaSession.setActionHandler('seekbackward', rewind)\r\n  }\r\n</script>\r\n\r\n<svelte:window on:keydown={handleKeydown} />\r\n\r\n<!-- svelte-ignore a11y-media-has-caption -->\r\n<div\r\n  class=\"player\"\r\n  class:pip\r\n  class:immersed\r\n  class:buffering\r\n  bind:this={container}\r\n  on:mousemove={resetImmerse}\r\n  on:touchmove={resetImmerse}\r\n  on:keypress={resetImmerse}\r\n  on:mouseleave={immersePlayer}>\r\n  <video\r\n    {src}\r\n    bind:this={video}\r\n    autoplay\r\n    bind:volume\r\n    bind:duration\r\n    bind:currentTime\r\n    bind:paused\r\n    bind:muted\r\n    on:waiting={showBuffering}\r\n    on:loadeddata={hideBuffering}\r\n    on:canplay={hideBuffering}\r\n    on:playing={hideBuffering}\r\n    on:timeupdate={hideBuffering}\r\n    on:loadedmetadata={resolveFps} />\r\n  <!-- svelte-ignore a11y-missing-content -->\r\n  <a href=\"#player\" class=\"miniplayer\" alt=\"miniplayer\" />\r\n  <div class=\"top\" />\r\n  <div class=\"middle\">\r\n    <div class=\"ctrl\" data-name=\"ppToggle\" on:click={playPause} on:dblclick={toggleFullscreen} />\r\n    {#if videos?.length > 1}\r\n      <span class=\"material-icons ctrl\" data-name=\"playLast\" on:click={playLast}> skip_previous </span>\r\n    {/if}\r\n    <span class=\"material-icons ctrl\" data-name=\"rewind\" on:click={rewind}> fast_rewind </span>\r\n    <span class=\"material-icons ctrl\" data-name=\"playPause\" on:click={playPause}> {paused ? 'play_arrow' : 'pause'} </span>\r\n    <span class=\"material-icons ctrl\" data-name=\"forward\" on:click={forward}> fast_forward </span>\r\n    {#if videos?.length > 1}\r\n      <span class=\"material-icons ctrl\" data-name=\"playNext\" on:click={playNext}> skip_next </span>\r\n    {/if}\r\n    <div data-name=\"bufferingDisplay\" />\r\n  </div>\r\n  <div class=\"bottom\">\r\n    <span class=\"material-icons ctrl\" title=\"Play/Pause [Space]\" data-name=\"playPause\" on:click={playPause}> {paused ? 'play_arrow' : 'pause'} </span>\r\n    {#if videos?.length > 1}\r\n      <span class=\"material-icons ctrl\" title=\"Next [N]\" data-name=\"playNext\" on:click={playNext}> skip_next </span>\r\n    {/if}\r\n    <div class=\"volume\">\r\n      <span class=\"material-icons ctrl\" title=\"Mute [M]\" data-name=\"toggleMute\" on:click={toggleMute}> {muted ? 'volume_off' : 'volume_up'} </span>\r\n      <input class=\"ctrl\" type=\"range\" min=\"0\" max=\"1\" step=\"any\" data-name=\"setVolume\" bind:value={volume} style=\"--value: {volume * 100}%\" />\r\n    </div>\r\n    <!-- svelte-ignore missing-declaration -->\r\n    {#if 'audioTracks' in HTMLVideoElement.prototype && video?.audioTracks?.length > 1}\r\n      <div class=\"audio-tracks dropdown dropup with-arrow\">\r\n        <span class=\"material-icons ctrl\" title=\"Audio Tracks [T]\" id=\"baudio\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\" data-name=\"audioButton\">\r\n          queue_music\r\n        </span>\r\n        <div class=\"dropdown-menu dropdown-menu-left ctrl custom-radio p-10 pb-5 text-capitalize\" aria-labelledby=\"baudio\" data-name=\"selectAudio\">\r\n          {#each video.audioTracks as track}\r\n            <input name=\"audio-radio-set\" type=\"radio\" id=\"audio-{track.id}-radio\" value={track.id} checked={track.enabled} />\r\n            <label for=\"audio-{track.id}-radio\" on:click={() => selectAudio(track.id)}>\r\n              {(track.language || (!Object.values(video.audioTracks).some(track => track.language === 'eng' || track.language === 'en') ? 'eng' : track.label)) +\r\n                (track.label ? ' - ' + track.label : '')}</label>\r\n          {/each}\r\n        </div>\r\n      </div>\r\n    {/if}\r\n    <div class=\"ctrl\" data-name=\"progressWrapper\" data-elapsed=\"00:00\" data-remaining=\"00:00\">\r\n      <div>\r\n        <div class=\"ts\">{toTS(targetTime)}</div>\r\n        <input\r\n          class=\"ctrl\"\r\n          type=\"range\"\r\n          min=\"0\"\r\n          max=\"1\"\r\n          step=\"any\"\r\n          data-name=\"setProgress\"\r\n          bind:value={progress}\r\n          on:mousedown={handleMouseDown}\r\n          on:mouseup={handleMouseUp}\r\n          on:input={handleProgress}\r\n          style=\"--value: {progress * 100}%\" />\r\n        <div class=\"ts\">{toTS(duration)}</div>\r\n        <img class=\"ctrl\" data-elapsed=\"00:00\" data-name=\"thumbnail\" alt=\"thumbnail\" src={thumbnail} />\r\n      </div>\r\n    </div>\r\n    {#if subHeaders && subHeaders.length}\r\n      <div class=\"subtitles dropdown dropup with-arrow\">\r\n        <span class=\"material-icons ctrl\" title=\"Subtitles\" id=\"bcap\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\" data-name=\"captionsButton\">\r\n          subtitles\r\n        </span>\r\n        <div class=\"dropdown-menu dropdown-menu-right ctrl custom-radio p-10 pb-5 text-capitalize\" aria-labelledby=\"bcap\" data-name=\"selectCaptions\">\r\n          {#each subHeaders as track}\r\n            {#if track}\r\n              <input name=\"subtitle-radio-set\" type=\"radio\" id=\"subtitle-{track.number}-radio\" value={track.numer} checked={track.number === subs.current} />\r\n              <label for=\"subtitle-{track.numer}-radio\" on:click={() => subs.selectCaptions(track.number)}>\r\n                {(track.language || (!Object.values(subs.headers).some(header => header.language === 'eng' || header.language === 'en') ? 'eng' : track.type)) +\r\n                  (track.name ? ' - ' + track.name : '')}\r\n              </label>\r\n            {/if}\r\n          {/each}\r\n        </div>\r\n      </div>\r\n    {/if}\r\n    {#if 'PresentationRequest' in window && canCast}\r\n      <span class=\"material-icons ctrl\" title=\"Cast Video [C]\" data-name=\"toggleCast\" on:click={toggleCast}>\r\n        {presentationConnection ? 'cast_connected' : 'cast'}\r\n      </span>\r\n    {/if}\r\n    {#if 'pictureInPictureEnabled' in document}\r\n      <span class=\"material-icons ctrl\" title=\"Popout Window [P]\" data-name=\"togglePopout\" on:click={togglePopout}>\r\n        {pip ? 'featured_video' : 'picture_in_picture'}\r\n      </span>\r\n    {/if}\r\n    <span class=\"material-icons ctrl\" title=\"Fullscreen [F]\" data-name=\"toggleFullscreen\" on:click={toggleFullscreen}>\r\n      {isFullscreen ? 'fullscreen_exit' : 'fullscreen'}\r\n    </span>\r\n  </div>\r\n</div>\r\n\r\n<style>\r\n  /* yes these are duplicates with framework */\r\n  .player {\r\n    position: absolute;\r\n    display: flex;\r\n    flex-direction: column;\r\n    justify-content: center;\r\n    align-content: center;\r\n    color: #ececec;\r\n    user-select: none;\r\n    font-family: Roboto, Arial, Helvetica, sans-serif;\r\n    z-index: 10;\r\n    will-change: width, right, bottom, position, display;\r\n    bottom: 2rem;\r\n    right: 2rem;\r\n    width: 25%;\r\n    height: auto;\r\n    transition: width 0.2s ease;\r\n    overflow: hidden;\r\n  }\r\n\r\n  .player:not(.miniplayer) {\r\n    bottom: 0;\r\n    right: 0;\r\n    position: relative;\r\n    width: 100%;\r\n    height: 100%;\r\n    transition: none !important;\r\n  }\r\n\r\n  .player:not(.miniplayer) .middle,\r\n  .player:not(.miniplayer) .bottom {\r\n    display: flex;\r\n  }\r\n\r\n  video {\r\n    position: relative;\r\n    flex: 0 1 auto;\r\n    z-index: -1;\r\n    width: 100%;\r\n    height: 100%;\r\n    background: #191c209d;\r\n    backdrop-filter: blur(10px);\r\n  }\r\n\r\n  .player:not(.miniplayer) video {\r\n    position: absolute;\r\n    background: none;\r\n  }\r\n\r\n  a.miniplayer {\r\n    z-index: 5;\r\n    position: absolute;\r\n    width: 100%;\r\n    height: 100%;\r\n  }\r\n\r\n  .pip {\r\n    background: #000;\r\n  }\r\n\r\n  .pip :global(canvas) {\r\n    left: 99.9% !important;\r\n    /*hack to hide the canvas but still keep it updating*/\r\n  }\r\n\r\n  .material-icons {\r\n    font-size: 2.2rem;\r\n    padding: 1.2rem;\r\n    transition: all 0.2s ease;\r\n    display: flex;\r\n  }\r\n\r\n  .immersed {\r\n    cursor: none;\r\n  }\r\n\r\n  .immersed .middle .ctrl,\r\n  .immersed .bottom {\r\n    opacity: 0;\r\n  }\r\n\r\n  .player:not(.miniplayer) a.miniplayer,\r\n  .bottom img[src=' '],\r\n  video[src='']:not([poster]),\r\n  :fullscreen .ctrl[data-name='toggleCast'],\r\n  :fullscreen .ctrl[data-name='togglePopout'] {\r\n    display: none !important;\r\n  }\r\n\r\n  .pip video {\r\n    visibility: hidden;\r\n  }\r\n\r\n  .top {\r\n    background: linear-gradient(to bottom, rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0.4) 25%, rgba(0, 0, 0, 0.2) 50%, rgba(0, 0, 0, 0.1) 75%, transparent);\r\n    display: none;\r\n    transition: 0.5s opacity ease;\r\n    border-width: 0;\r\n    border-top-width: 1px;\r\n    border-image-slice: 1;\r\n    border-style: solid;\r\n    border-image-source: linear-gradient(90deg, #e5204c var(--download), rgba(0, 0, 0, 0.8) var(--download));\r\n    grid-template-columns: 1fr auto 1fr;\r\n  }\r\n  .middle {\r\n    height: 100%;\r\n    flex: 1;\r\n    display: none;\r\n    flex-direction: row;\r\n    position: relative;\r\n    justify-content: center;\r\n    align-items: center;\r\n  }\r\n\r\n  .middle div[data-name='bufferingDisplay'] {\r\n    border: 4px solid #ffffff00;\r\n    border-top: 4px solid #fff;\r\n    border-radius: 50%;\r\n    width: 40px;\r\n    height: 40px;\r\n    animation: spin 1s linear infinite;\r\n    opacity: 0;\r\n    transition: 0.5s opacity ease;\r\n    position: absolute;\r\n    filter: drop-shadow(0 0 8px #000);\r\n  }\r\n\r\n  .buffering .middle div[data-name='bufferingDisplay'] {\r\n    opacity: 1 !important;\r\n  }\r\n\r\n  @keyframes spin {\r\n    0% {\r\n      transform: rotate(0deg);\r\n    }\r\n\r\n    100% {\r\n      transform: rotate(360deg);\r\n    }\r\n  }\r\n\r\n  .middle .ctrl[data-name='ppToggle'] {\r\n    position: absolute;\r\n    width: 100%;\r\n    height: 100%;\r\n    display: block;\r\n    z-index: 2;\r\n  }\r\n\r\n  .middle .ctrl {\r\n    font-size: 4rem;\r\n    margin: 2rem;\r\n    z-index: 3;\r\n    display: none;\r\n  }\r\n\r\n  @media (pointer: none), (pointer: coarse) {\r\n    .middle .ctrl {\r\n      display: flex;\r\n    }\r\n  }\r\n\r\n  .middle .ctrl[data-name='playPause'] {\r\n    font-size: 6rem;\r\n  }\r\n\r\n  .middle .ctrl,\r\n  .bottom .ctrl:hover {\r\n    filter: drop-shadow(0 0 8px #000);\r\n  }\r\n\r\n  .bottom {\r\n    background: linear-gradient(to top, rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0.4) 25%, rgba(0, 0, 0, 0.2) 50%, rgba(0, 0, 0, 0.1) 75%, transparent);\r\n    display: none;\r\n    transition: 0.5s opacity ease;\r\n  }\r\n\r\n  .bottom .ctrl {\r\n    cursor: pointer;\r\n  }\r\n\r\n  input[type='range'] {\r\n    -webkit-appearance: none;\r\n    background: transparent;\r\n    margin: 0;\r\n    cursor: pointer;\r\n    height: 8px;\r\n  }\r\n\r\n  input[type='range']:focus {\r\n    outline: none;\r\n  }\r\n\r\n  input[type='range']::-webkit-slider-runnable-track {\r\n    height: 3px;\r\n  }\r\n\r\n  input[type='range']::-webkit-slider-thumb {\r\n    height: 0;\r\n    width: 0;\r\n    border-radius: 50%;\r\n    background: #ff3c00;\r\n    -webkit-appearance: none;\r\n    appearance: none;\r\n    transition: all 0.1s ease;\r\n  }\r\n\r\n  input[type='range']:hover::-webkit-slider-thumb {\r\n    height: 12px;\r\n    width: 12px;\r\n    margin-top: -4px;\r\n  }\r\n\r\n  input[type='range'] {\r\n    --volume: 0%;\r\n  }\r\n\r\n  input[type='range']::-webkit-slider-runnable-track {\r\n    background: linear-gradient(90deg, #ff3c00 var(--value), rgba(255, 255, 255, 0.2) var(--value));\r\n  }\r\n\r\n  .bottom .volume {\r\n    display: flex;\r\n    width: auto;\r\n  }\r\n\r\n  .bottom .volume:hover input[type='range'] {\r\n    width: 5vw;\r\n    display: inline-block;\r\n    transition: all 0.1s ease;\r\n    margin-right: 1rem;\r\n  }\r\n\r\n  .bottom .volume input[type='range'] {\r\n    width: 0;\r\n    transition: all 0.1s ease;\r\n    height: 100%;\r\n  }\r\n\r\n  .bottom input[type='range'][data-name='setProgress'],\r\n  .bottom div[data-name='progressWrapper'],\r\n  .bottom div[data-name='progressWrapper'] > div {\r\n    display: flex;\r\n    width: 100%;\r\n    height: 100%;\r\n    position: relative;\r\n  }\r\n\r\n  .bottom input[type='range'][data-name='setProgress'] ~ img,\r\n  .bottom input[type='range'][data-name='setProgress']::before {\r\n    pointer-events: none;\r\n    opacity: 0;\r\n    position: absolute;\r\n    transform: translate(-50%, -100%);\r\n    font-family: Roboto, Arial, Helvetica, sans-serif;\r\n    white-space: nowrap;\r\n    align-self: center;\r\n    left: var(--progress);\r\n    font-weight: 600;\r\n    transition: 0.2s opacity ease;\r\n  }\r\n\r\n  .bottom input[type='range'][data-name='setProgress'] ~ img {\r\n    top: -2rem;\r\n    width: 150px;\r\n  }\r\n\r\n  .bottom input[type='range'][data-name='setProgress']::before {\r\n    top: 0.5rem;\r\n    content: attr(data-elapsed);\r\n    color: #ececec;\r\n  }\r\n\r\n  .bottom input[type='range'][data-name='setProgress']:active ~ img,\r\n  .bottom input[type='range'][data-name='setProgress']:active::before {\r\n    opacity: 1;\r\n  }\r\n\r\n  .bottom div[data-name='progressWrapper'] .ts {\r\n    color: #ececec;\r\n    font-size: 1.8rem !important;\r\n    white-space: nowrap;\r\n    align-self: center;\r\n    cursor: default;\r\n    line-height: var(--base-line-height);\r\n    padding: 0 1.2rem;\r\n    font-weight: 600;\r\n  }\r\n\r\n  @media (pointer: none), (pointer: coarse) {\r\n    .bottom .ctrl[data-name='playPause'],\r\n    .bottom .ctrl[data-name='playNext'],\r\n    .bottom .volume,\r\n    .bottom .ctrl[data-name='toggleFullscreen'] {\r\n      display: none;\r\n    }\r\n  }\r\n</style>\r\n","<script>\n  import Player from './modules/Player.svelte'\n  import { videoRx } from './modules/util.js'\n\n  const DOMPARSER = new DOMParser().parseFromString.bind(new DOMParser())\n  let name = ''\n  let files\n\n  navigator.serviceWorker.getRegistrations().then((workers = []) => {\n    // register a root service worker if user didin't come from home page\n    if (!workers.find(worker => worker.scope === location.origin + '/')) {\n      navigator.serviceWorker.register('/sw.js')\n    }\n  })\n\n  // loading files\n  function handleDrop({ dataTransfer }) {\n    handleItems([...dataTransfer.items])\n  }\n\n  function handlePaste({ clipboardData }) {\n    handleItems([...clipboardData.items])\n  }\n  async function handleItems(items) {\n    const promises = items.map(item => {\n      if (item.type.indexOf('video/') === 0) {\n        return item.getAsFile()\n      }\n      if (item.type === 'text/plain') {\n        return new Promise(resolve =>\n          item.getAsString(url => {\n            if (videoRx.test(url)) {\n              const filename = url.substring(Math.max(url.lastIndexOf('\\\\'), url.lastIndexOf('/')) + 1)\n              const name = filename.substring(0, filename.lastIndexOf('.')) || filename\n              resolve({\n                name,\n                url,\n                type: 'video/'\n              })\n            }\n            resolve()\n          })\n        )\n      }\n      if (item.type === 'text/html') {\n        return new Promise(resolve =>\n          item.getAsString(string => {\n            const elems = DOMPARSER(string, 'text/html').querySelectorAll('video')\n            if (elems.length) resolve(elems.map(video => video?.src))\n            resolve()\n          })\n        )\n      }\n      if (!item.type) {\n        let folder = item.webkitGetAsEntry()\n        folder = folder.isDirectory && folder\n        if (folder) {\n          return new Promise(resolve => {\n            folder.createReader().readEntries(async entries => {\n              const filePromises = entries.filter(entry => entry.isFile).map(file => new Promise(resolve => file.file(resolve)))\n              resolve(await Promise.all(filePromises))\n            })\n          })\n        }\n        return\n      }\n      return\n    })\n    files = (await Promise.all(promises)).flat().filter(i => i)\n  }\n\n  if ('launchQueue' in window) {\n    launchQueue.setConsumer(async launchParams => {\n      if (!launchParams.files.length) {\n        return\n      }\n      const promises = launchParams.files.map(file => file.getFile())\n      // for some fucking reason, the same file can get passed multiple times, why? I still want to future-proof multi-files\n      files = (await Promise.all(promises)).filter((file, index, all) => {\n        return (\n          all.findIndex(search => {\n            return search.name === file.name && search.size === file.size && search.lastModified === file.lastModified\n          }) === index\n        )\n      })\n      console.log(files)\n    })\n  }\n  function handlePopup() {\n    if (!files.length) {\n      let input = document.createElement('input')\n      input.type = 'file'\n      input.multiple = 'multiple'\n\n      input.onchange = ({ target }) => {\n        files = [...target.files]\n        input = null\n      }\n      input.click()\n    }\n  }\n</script>\n\n<div class=\"page-wrapper with-navbar-fixed-bottom\" on:click={handlePopup}>\n  <Player bind:files bind:name />\n</div>\n\n<svelte:head>\n  <title>{name || 'Video Player'}</title>\n</svelte:head>\n\n<svelte:window on:drop|preventDefault={handleDrop} on:dragover|preventDefault on:paste|preventDefault={handlePaste} />\n\n<style>\n  * {\n    user-select: none;\n  }\n</style>\n"],"names":[],"sourceRoot":""}