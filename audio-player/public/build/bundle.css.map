{"version":3,"file":"build/bundle.css","mappings":"AA4BE,sBAAQ,wBACmB,CACzB,qEAAuD,CACxD,iCAEkB,GACb,YACW,CACd,KACK,OACI,CACT;AAtCL,q9DAAq9D,C;AC4Bn9D,uBAAU,cACO,CAChB,6BACe,0CAC6B,CAC5C,sBACQ,YACM,CACb,kBAAmB,CACnB,sBAAuB;AArC3B,q0EAAq0E,C;ACwUn0E,6BAAG,gBACgB,CAClB,2CACe,YACD,CACd,gCACI,kBACgB,CACnB,eAAgB,CAChB,cAAe,CAChB,gDACoB,uBACK,CACxB,sBAAuB,CACvB,QAAS,CACT,cAAe,CACf,UAAW,CACZ,sDAE0B,YACZ,CACd,+EAEmD,UACvC,CACZ,sEAE0C,QAChC,CACT,OAAQ,CACR,iBAAkB,CAClB,kBAAmB,CACnB,uBAAwB,CACxB,eAAgB,CAChB,wBAAyB,CAC1B,4EAEgD,WACnC,CACZ,UAAW,CACX,eAAgB,CACjB,gDAEoB,WACP,CACb,+EAEmD,8FAC6C,CAChG,qCAES,cACO,CAChB,kCAEM,YACQ,CACb,aAAc,CACd,YAAa,CACb,kBAAmB,CACnB,sBAAuB,CACxB,oCAEQ,YACM,CACb,kBAAmB,CACnB,sBAAuB,CACxB,kCAEM,iBACa,CAClB,aAAc,CACf,wCACY,iBACO,CAClB,kBAAmB,CACnB,aAAc,CACf,kCACM,WACO;AAvZhB,qgnBAAqgnB,C;ACqHngnB,gBAAG,gBACgB,CAClB,8BACe,wBACW,CACzB,WAAY;AA1HhB,yuLAAyuL,C","sources":["webpack://svelte-app/./src/modules/InstallPrompt.svelte","webpack://svelte-app/./src/modules/SongList.svelte","webpack://svelte-app/./src/modules/Player.svelte","webpack://svelte-app/./src/App.svelte"],"sourcesContent":["<script>\r\n  let deferredPrompt\r\n\r\n  window.addEventListener('beforeinstallprompt', e => {\r\n    e.preventDefault()\r\n    deferredPrompt = e\r\n  })\r\n  async function promptInstall() {\r\n    deferredPrompt.prompt()\r\n    const { outcome } = await deferredPrompt.userChoice\r\n    if (outcome === 'accepted') {\r\n      deferredPrompt = null\r\n    }\r\n  }\r\n  function dismiss() {\r\n    deferredPrompt = null\r\n  }\r\n</script>\r\n\r\n{#if deferredPrompt}\r\n  <div class=\"alert alert-success filled-dm show\" on:click={promptInstall}>\r\n    <h4 class=\"alert-heading\">Install</h4>\r\n    <button class=\"close\" type=\"button\" on:click={dismiss}><span>Ã—</span></button>\r\n    Click here to install the app for more features!\r\n  </div>\r\n{/if}\r\n\r\n<style>\r\n  .alert {\r\n    display: block !important;\r\n    animation: fly-in 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);\r\n  }\r\n\r\n  @keyframes fly-in {\r\n    0% {\r\n      right: -50rem;\r\n    }\r\n    100% {\r\n      right: 0;\r\n    }\r\n  }\r\n</style>\r\n","<script>\r\n  import { toTS } from './util.js'\r\n  import { createEventDispatcher } from 'svelte'\r\n\r\n  export let current\r\n  export let songs\r\n  const dispatch = createEventDispatcher()\r\n  function select(song) {\r\n    if (song !== current) current = song\r\n  }\r\n</script>\r\n\r\n<div class=\"col-md-5 bg-dark overflow-y-scroll h-half h-md-full p-20\" on:click={() => dispatch('popup')}>\r\n  {#if songs.length}\r\n    {#each songs as song}\r\n      <div class=\"d-flex w-full pointer font-size-20 {song === current ? 'text-primary' : 'text-muted'}\" on:click={select(song)}>\r\n        <div class=\"material-icons font-size-20 center pr-20\">\r\n          {song === current ? 'volume_up' : 'play_arrow'}\r\n        </div>\r\n        <div class=\"text-truncate\">{[song.number, song.name].filter(s => s).join('. ')}</div>\r\n        <div class=\"ml-auto pl-20\">{toTS(song.duration)}</div>\r\n      </div>\r\n    {/each}\r\n  {:else}\r\n    <div class=\"font-size-24 font-weight-bold center text-center h-full pointer\">Drag and drop, paste or click here to select a file/folder to play.</div>\r\n  {/if}\r\n</div>\r\n\r\n<style>\r\n  .pointer {\r\n    cursor: pointer;\r\n  }\r\n  .pointer:hover {\r\n    color: var(--dm-base-text-color) !important;\r\n  }\r\n  .center {\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n  }\r\n</style>\r\n","<script>\r\n  import { toTS } from './util.js'\r\n  import SongList from './SongList.svelte'\r\n  import { createEventDispatcher } from 'svelte'\r\n  import { parseBlob } from 'music-metadata-browser'\r\n  import Peer from './peer.js'\r\n\r\n  const dispatch = createEventDispatcher()\r\n  export let name = ''\r\n  let src = null\r\n  let audio = null\r\n  let volume = localStorage.getItem('volume') || 1\r\n  $: localStorage.setItem('volume', volume)\r\n  export let files = []\r\n  $: updateFiles(files)\r\n  $: progress = currentTime / duration\r\n  $: targetTime = currentTime\r\n  let current = null\r\n  $: setSource(current)\r\n  let songs = []\r\n  let duration = 0.1\r\n  let currentTime = 0\r\n  let paused = true\r\n  let muted = false\r\n  let loop = false\r\n  let wasPaused = true\r\n  let shuffle = false\r\n  let cover = './512.png'\r\n  let defaultCover = './512.png'\r\n  $: navigator.mediaSession?.setPositionState({\r\n    duration: duration || 0,\r\n    playbackRate: 1,\r\n    position: currentTime || 0\r\n  })\r\n  $: updateMedia(current, cover)\r\n  function updateMedia(current, cover) {\r\n    if ('mediaSession' in navigator) {\r\n      navigator.mediaSession.metadata = new MediaMetadata({\r\n        title: current?.name || 'Audio Player',\r\n        artist: current?.artist || '',\r\n        album: current?.album || '',\r\n        artwork: [\r\n          {\r\n            src: cover,\r\n            sizes: '256x256',\r\n            type: 'image/jpg'\r\n          }\r\n        ]\r\n      })\r\n    }\r\n  }\r\n\r\n  if ('mediaSession' in navigator) {\r\n    navigator.mediaSession.setActionHandler('play', playPause)\r\n    navigator.mediaSession.setActionHandler('pause', playPause)\r\n    navigator.mediaSession.setActionHandler('nexttrack', playNext)\r\n    navigator.mediaSession.setActionHandler('previoustrack', playLast)\r\n  }\r\n\r\n  let presentationRequest = null\r\n  let presentationConnection = null\r\n  let presentationPort = null\r\n  let canCast = false\r\n\r\n  $: updateCastTime(currentTime)\r\n\r\n  function updateCastTime(currentTime) {\r\n    if (presentationPort?.readyState === 'open') {\r\n      presentationPort.send(JSON.stringify({ current: currentTime }))\r\n    }\r\n  }\r\n\r\n  if ('PresentationRequest' in window) {\r\n    const handleAvailability = aval => {\r\n      canCast = !!aval\r\n    }\r\n    presentationRequest = new PresentationRequest(['build/cast.html'])\r\n    presentationRequest.addEventListener('connectionavailable', e => initCast(e))\r\n    navigator.presentation.defaultRequest = presentationRequest\r\n    presentationRequest.getAvailability().then(aval => {\r\n      aval.onchange = e => handleAvailability(e.target.value)\r\n      handleAvailability(aval.value)\r\n    })\r\n  }\r\n\r\n  function toggleCast() {\r\n    if (audio.readyState) {\r\n      if (presentationConnection) {\r\n        presentationConnection?.terminate()\r\n      } else {\r\n        presentationRequest.start()\r\n      }\r\n    }\r\n  }\r\n  let peer = null\r\n  $: updateCastState(audio?.readyState && current)\r\n  async function updateCastState(current) {\r\n    if (current && presentationPort?.readyState === 'open') {\r\n      const stream = audio.captureStream()\r\n      peer.pc.addTrack(stream.getAudioTracks()[0], stream)\r\n      paused = false // pauses for some reason\r\n      presentationPort.send(\r\n        JSON.stringify({\r\n          duration: current.duration,\r\n          current: currentTime,\r\n          arist: current.artist,\r\n          title: current.name\r\n        })\r\n      )\r\n      if (current.cover) {\r\n        const buffer = await current.cover.arrayBuffer()\r\n        const array = new Uint8Array(buffer)\r\n        for (let pos = 0; pos < array.length; pos += 16000) {\r\n          const sliced = array.slice(pos, pos + 16000)\r\n          presentationPort.send(sliced)\r\n        }\r\n        presentationPort.send(JSON.stringify({ ended: true }))\r\n      }\r\n    }\r\n  }\r\n  function initCast(event) {\r\n    peer = new Peer({ polite: true })\r\n\r\n    presentationConnection = event.connection\r\n    presentationConnection.addEventListener('terminate', () => {\r\n      presentationConnection = null\r\n      peer = null\r\n    })\r\n\r\n    peer.signalingPort.onmessage = ({ data }) => {\r\n      presentationConnection.send(data)\r\n    }\r\n\r\n    presentationConnection.addEventListener('message', ({ data }) => {\r\n      peer.signalingPort.postMessage(data)\r\n    })\r\n\r\n    peer.dc.onopen = () => {\r\n      presentationPort = peer.pc.createDataChannel('current', { negotiated: true, id: 2 })\r\n      presentationConnection.addEventListener('terminate', () => presentationPort.close())\r\n      presentationPort.onopen = () => updateCastState(current)\r\n    }\r\n  }\r\n\r\n  async function updateFiles(files) {\r\n    if (files.length) {\r\n      const image = files.find(file => file.type.indexOf('image') === 0)\r\n      const audio = files.filter(file => file.type.indexOf('audio') === 0)\r\n      if (audio) {\r\n        songs = []\r\n        current = null\r\n        src = null\r\n        paused = true\r\n      }\r\n      const songDataPromises = audio.map(async file => {\r\n        const { common, format } = await parseBlob(file)\r\n        const name = common?.title || file.name.substring(0, file.name.lastIndexOf('.')) || file.name\r\n        const artist = common?.artist\r\n        const album = common?.album\r\n        // note: this is utterly fucking retarded, the browser isn't capable of creating a object url from an image file blob in this case, but a data URI works!!!!! WHY?\r\n        const cover = (common?.picture?.length && new Blob([common.picture[0].data], { type: common.picture[0].format })) || image\r\n        const duration = format?.duration\r\n        const number = common?.track?.no\r\n        return { file, name, artist, album, cover, duration, number }\r\n      })\r\n      songs = (await Promise.all(songDataPromises)).sort((a, b) => (a.file.name > b.file.name ? 1 : b.file.name > a.file.name ? -1 : 0))\r\n      current = songs[0]\r\n    }\r\n  }\r\n\r\n  function setSource(song) {\r\n    if (src) URL.revokeObjectURL(src)\r\n    if (song) {\r\n      src = song.file.url || URL.createObjectURL(song.file)\r\n      name = song.name\r\n      setCover(song.cover)\r\n    } else {\r\n      src = null\r\n      name = ''\r\n    }\r\n  }\r\n  function setCover(file) {\r\n    if (cover) URL.revokeObjectURL(cover)\r\n    if (file) {\r\n      cover = file.url || URL.createObjectURL(file)\r\n    } else {\r\n      cover = defaultCover\r\n    }\r\n  }\r\n\r\n  // todo use a store\r\n  function handleMouseDown({ target }) {\r\n    wasPaused = paused\r\n    paused = true\r\n    targetTime = target.value * duration\r\n  }\r\n  function handleMouseUp() {\r\n    paused = wasPaused\r\n    currentTime = targetTime\r\n  }\r\n  function handleProgress({ target }) {\r\n    targetTime = target.value * duration\r\n  }\r\n\r\n  function playPause() {\r\n    paused = !paused\r\n  }\r\n  function toggleMute() {\r\n    muted = !muted\r\n  }\r\n  function toggleLoop() {\r\n    loop = !loop\r\n  }\r\n  function playNext() {\r\n    current = songs[(songs.indexOf(current) + 1) % songs.length]\r\n  }\r\n  function playLast() {\r\n    const index = songs.indexOf(current)\r\n    current = songs[index === 0 ? songs.length - 1 : index - 1]\r\n  }\r\n  function toggleShuffle() {\r\n    shuffle = !shuffle\r\n    if (shuffle) {\r\n      songs = songs.sort(() => 0.5 - Math.random())\r\n    } else {\r\n      songs = songs.sort((a, b) => (a.file.name > b.file.name ? 1 : b.file.name > a.file.name ? -1 : 0))\r\n    }\r\n  }\r\n\r\n  function handleKeydown({ key }) {\r\n    switch (key) {\r\n      case ' ':\r\n        playPause()\r\n        break\r\n      case 'n':\r\n        playNext()\r\n        break\r\n      case 'm':\r\n        muted = !muted\r\n        break\r\n      case 'c':\r\n        toggleCast()\r\n        break\r\n      case 'ArrowLeft':\r\n        currentTime = Math.max(currentTime - 2, 0)\r\n        break\r\n      case 'ArrowRight':\r\n        currentTime = Math.min(currentTime + 2, duration)\r\n        break\r\n      case 'ArrowUp':\r\n        volume = Math.min(1, volume + 0.05)\r\n        break\r\n      case 'ArrowDown':\r\n        volume = Math.max(0, volume - 0.05)\r\n        break\r\n    }\r\n  }\r\n</script>\r\n\r\n<svelte:window on:keydown={handleKeydown} />\r\n\r\n<!-- svelte-ignore a11y-media-has-caption -->\r\n<audio\r\n  {src}\r\n  bind:this={audio}\r\n  autoplay\r\n  bind:volume\r\n  bind:duration\r\n  bind:currentTime\r\n  bind:paused\r\n  bind:muted\r\n  {loop}\r\n  on:ended={() => !loop && playNext()}\r\n  on:loadedmetadata={updateCastState} />\r\n<div class=\"content-wrapper row overflow-hidden\">\r\n  <div class=\"col-md-7 p-20 center h-half h-md-full bg-dark\">\r\n    <img src={cover} alt=\"cover\" class=\"shadow-lg pointer\" on:click={playPause} />\r\n  </div>\r\n  <SongList {songs} bind:current on:popup={() => dispatch('popup')} />\r\n</div>\r\n<nav class=\"navbar navbar-fixed-bottom p-0 d-flex flex-column border-0 shadow-lg bg-dark-light\">\r\n  <div class=\"d-flex w-full prog\">\r\n    <input\r\n      class=\"w-full top-0\"\r\n      type=\"range\"\r\n      min=\"0\"\r\n      max=\"1\"\r\n      bind:value={progress}\r\n      on:mousedown={handleMouseDown}\r\n      on:mouseup={handleMouseUp}\r\n      on:input={handleProgress}\r\n      step=\"any\"\r\n      style=\"--value: {progress * 100}%\" />\r\n  </div>\r\n  <div class=\"d-flex w-full flex-grow-1 px-20 justify-content-between\">\r\n    <div class=\"d-flex align-items-center\">\r\n      <span class=\"material-icons font-size-20 ctrl pointer\" type=\"button\" on:click={playLast}> skip_previous </span>\r\n      <span class=\"material-icons font-size-24 ctrl pointer\" type=\"button\" on:click={playPause}>\r\n        {paused ? 'play_arrow' : 'pause'}\r\n      </span>\r\n      <span class=\"material-icons font-size-20 ctrl pointer\" type=\"button\" on:click={playNext}> skip_next </span>\r\n      <div class=\"text-muted center ml-10 text-nowrap\">\r\n        {toTS(targetTime, true)} / {toTS(duration, true)}\r\n      </div>\r\n    </div>\r\n    <div class=\"center px-20 mw-0\">\r\n      <div class=\"text-truncate text-muted\">{[current?.artist, current?.name].filter(c => c).join(' - ')}</div>\r\n    </div>\r\n    <div class=\"d-flex align-items-center\">\r\n      {#if 'PresentationRequest' in window && canCast}\r\n        <span class=\"material-icons font-size-20 ctrl pointer\" title=\"Cast Video [C]\" data-name=\"toggleCast\" on:click={toggleCast}>\r\n          {presentationConnection ? 'cast_connected' : 'cast'}\r\n        </span>\r\n      {/if}\r\n      <span class=\"material-icons font-size-20 ctrl pointer\" type=\"button\" on:click={toggleMute}>\r\n        {muted ? 'volume_off' : 'volume_up'}\r\n      </span>\r\n      <input class=\"ml-auto px-5 h-half\" type=\"range\" min=\"0\" max=\"1\" bind:value={volume} step=\"any\" style=\"--value: {volume * 100}%\" />\r\n      <span class=\"material-icons font-size-20 ctrl pointer\" type=\"button\" on:click={toggleLoop}>\r\n        {loop ? 'repeat_one' : 'repeat'}\r\n      </span>\r\n      <span class=\"material-icons font-size-20 ctrl pointer\" type=\"button\" on:click={toggleShuffle}>\r\n        {shuffle ? 'shuffle' : 'sort'}\r\n      </span>\r\n    </div>\r\n  </div>\r\n</nav>\r\n\r\n<style>\r\n  * {\r\n    user-select: none;\r\n  }\r\n  img:not([src]) {\r\n    display: none;\r\n  }\r\n  img {\r\n    object-fit: contain;\r\n    max-height: 100%;\r\n    max-width: 100%;\r\n  }\r\n  input[type='range'] {\r\n    -webkit-appearance: none;\r\n    background: transparent;\r\n    margin: 0;\r\n    cursor: pointer;\r\n    height: 8px;\r\n  }\r\n\r\n  input[type='range']:focus {\r\n    outline: none;\r\n  }\r\n\r\n  input[type='range']::-webkit-slider-runnable-track {\r\n    height: 3px;\r\n  }\r\n\r\n  input[type='range']::-webkit-slider-thumb {\r\n    height: 0;\r\n    width: 0;\r\n    border-radius: 50%;\r\n    background: #ff3c00;\r\n    -webkit-appearance: none;\r\n    appearance: none;\r\n    transition: all 0.1s ease;\r\n  }\r\n\r\n  input[type='range']:hover::-webkit-slider-thumb {\r\n    height: 12px;\r\n    width: 12px;\r\n    margin-top: -4px;\r\n  }\r\n\r\n  input[type='range'] {\r\n    --volume: 0%;\r\n  }\r\n\r\n  input[type='range']::-webkit-slider-runnable-track {\r\n    background: linear-gradient(90deg, #ff3c00 var(--value), rgba(255, 255, 255, 0.2) var(--value));\r\n  }\r\n\r\n  .pointer {\r\n    cursor: pointer;\r\n  }\r\n\r\n  .ctrl {\r\n    width: 3.5rem;\r\n    height: 3.5rem;\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n  }\r\n\r\n  .center {\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n  }\r\n\r\n  .prog {\r\n    position: relative;\r\n    height: 0.2rem;\r\n  }\r\n  .prog input {\r\n    position: absolute;\r\n    margin-top: -0.7rem;\r\n    height: 1.4rem;\r\n  }\r\n  .mw-0 {\r\n    min-width: 0;\r\n  }\r\n</style>\r\n","<script>\n  import InstallPrompt from './modules/InstallPrompt.svelte'\n  import Player from './modules/Player.svelte'\n\n  const DOMPARSER = new DOMParser().parseFromString.bind(new DOMParser())\n  let name = ''\n  let files\n\n  navigator.serviceWorker.getRegistrations().then((workers = []) => {\n    // register a root service worker if user didin't come from home page\n    if (!workers.find(worker => worker.scope === location.origin + '/')) {\n      navigator.serviceWorker.register('/sw.js')\n    }\n  })\n\n  // loading files\n  function handleDrop({ dataTransfer }) {\n    handleItems([...dataTransfer.items])\n  }\n\n  function handlePaste({ clipboardData }) {\n    handleItems([...clipboardData.items])\n  }\n  const audioRx = /\\.(3gp|3gpp|3g2|aac|adts|ac3|amr|eac3|flac|mp3|m4a|mp4|mp4a|mpga|mp2|mp2a|mp3|m2a|m3a|oga|ogg|mogg|spx|opus|raw|wav|weba)$/i\n  async function handleItems(items) {\n    const promises = items.map(item => {\n      if (item.type.indexOf('audio') === 0 || item.type.indexOf('image') === 0 || item.type.indexOf('video') === 0) {\n        return item.getAsFile()\n      }\n      if (item.type === 'text/plain') {\n        return new Promise(resolve =>\n          item.getAsString(url => {\n            if (audioRx.test(url)) {\n              const filename = url.substring(Math.max(url.lastIndexOf('\\\\'), url.lastIndexOf('/')) + 1)\n              const name = filename.substring(0, filename.lastIndexOf('.')) || filename\n              resolve({\n                name,\n                url,\n                type: 'audio/'\n              })\n            }\n            resolve()\n          })\n        )\n      }\n      if (item.type === 'text/html') {\n        return new Promise(resolve =>\n          item.getAsString(string => {\n            const elems = DOMPARSER(string, 'text/html').querySelectorAll('audio')\n            if (elems.length) resolve(elems.map(audio => audio?.src))\n            resolve()\n          })\n        )\n      }\n      if (!item.type) {\n        let folder = item.webkitGetAsEntry()\n        folder = folder.isDirectory && folder\n        if (folder) {\n          return new Promise(resolve => {\n            folder.createReader().readEntries(async entries => {\n              const filePromises = entries.filter(entry => entry.isFile).map(file => new Promise(resolve => file.file(resolve)))\n              resolve(await Promise.all(filePromises))\n            })\n          })\n        }\n        return\n      }\n      return\n    })\n    files = (await Promise.all(promises)).flat().filter(i => i)\n  }\n\n  if ('launchQueue' in window) {\n    launchQueue.setConsumer(async launchParams => {\n      if (!launchParams.files.length) {\n        return\n      }\n      const promises = launchParams.files.map(file => file.getFile())\n      // for some fucking reason, the same file can get passed multiple times, why? I still want to future-proof multi-files\n      files = (await Promise.all(promises)).filter((file, index, all) => {\n        return (\n          all.findIndex(search => {\n            return search.name === file.name && search.size === file.size && search.lastModified === file.lastModified\n          }) === index\n        )\n      })\n      console.log(files)\n    })\n  }\n  function handlePopup() {\n    if (!files.length) {\n      let input = document.createElement('input')\n      input.type = 'file'\n      input.multiple = 'multiple'\n\n      input.onchange = ({ target }) => {\n        files = [...target.files]\n        input = null\n      }\n      input.click()\n    }\n  }\n</script>\n\n<div class=\"sticky-alerts d-flex flex-column-reverse\">\n  <InstallPrompt />\n</div>\n<div class=\"page-wrapper with-navbar-fixed-bottom\">\n  <Player bind:name bind:files on:popup={handlePopup} />\n</div>\n\n<svelte:head>\n  <title>{name || 'Audio Player'}</title>\n</svelte:head>\n\n<svelte:window on:drop|preventDefault={handleDrop} on:dragover|preventDefault on:paste|preventDefault={handlePaste} />\n\n<style>\n  * {\n    user-select: none;\n  }\n  .sticky-alerts {\n    --sticky-alerts-top: auto;\n    bottom: 1rem;\n  }\n</style>\n"],"names":[],"sourceRoot":""}